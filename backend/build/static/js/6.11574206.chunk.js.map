{"version":3,"sources":["../../../src/hooks/use-focus-trap.ts","../../../src/hooks/use-inert-others.ts","../../../src/internal/portal-force-root.tsx","../../../../src/components/portal/portal.tsx","../../../src/internal/stack-context.tsx","../../../../src/components/dialog/dialog.tsx","../../../../src/components/disclosure/disclosure.tsx"],"names":["Features","useFocusTrap","container","features","All","initialFocus","containers","restoreElement","useRef","window","document","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","featuresInitialFocus","useEffect","focusElement","activeElement","focusIn","Focus","FocusResult","console","useWindowEvent","event","Keys","allContainers","Set","previous","toElement","contains","interactables","originals","inert","element","restore","original","ForcePortalRootContext","createContext","ForcePortalRoot","props","value","force","usePortalTarget","forceInRoot","useContext","groupTarget","useState","existingRoot","root","target","setTarget","DEFAULT_PORTAL_TAG","Portal","passthroughProps","ready","useServerHandoffComplete","useIsoMorphicEffect","createPortal","render","defaultTag","name","DEFAULT_GROUP_TAG","PortalGroupContext","StackMessage","StackContext","StackProvider","children","onUpdate","type","parentUpdate","notify","useCallback","args","DialogStates","ActionTypes","reducers","state","action","titleId","id","DialogContext","useDialogContext","component","context","err","Error","Dialog","stateReducer","match","DialogRenderFeatures","DialogRoot","forwardRefWithAs","open","onClose","rest","nestedDialogCount","setNestedDialogCount","usesOpenClosedState","useOpenClosed","State","internalDialogRef","dialogRef","useSyncRefs","hasOpen","hasOnClose","dialogState","visible","useReducer","descriptionId","dispatch","close","setTitleId","enabled","hasNestedDialogs","hasParentDialog","position","parent","FocusTrapFeatures","leaf","child","interactable","useInertOthers","overflow","paddingRight","scrollbarWidth","observer","IntersectionObserver","entries","entry","useDescriptions","describedby","DescriptionProvider","useId","contextBag","useMemo","slot","Open","propsWeControl","ref","role","onClick","message","count","React","Overlay","overlayRef","handleClick","isDisabledReactIssue7711","Object","Title","Description","DisclosureStates","disclosureState","Closed","linkedPanel","buttonId","panelId","DisclosureContext","useDisclosureContext","Disclosure","DisclosureAPIContext","useDisclosureAPIContext","DisclosurePanelContext","DEFAULT_DISCLOSURE_TAG","defaultOpen","reducerBag","CloseDisclosure","focusableElement","api","Button","internalButtonRef","buttonRef","panelContext","isWithinPanel","handleKeyDown","ToggleDisclosure","handleKeyUp","useResolveButtonType","onKeyDown","onKeyUp","PanelRenderFeatures","Panel","panelRef","LinkPanel","UnlinkPanel"],"mappings":"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","file":"static/js/6.11574206.chunk.js","sourcesContent":["import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n","import { MutableRefObject } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nlet interactables = new Set<HTMLElement>()\nlet originals = new Map<HTMLElement, { 'aria-hidden': string | null; inert: boolean }>()\n\nfunction inert(element: HTMLElement) {\n  element.setAttribute('aria-hidden', 'true')\n  // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n  element.inert = true\n}\n\nfunction restore(element: HTMLElement) {\n  let original = originals.get(element)\n  if (!original) return\n\n  if (original['aria-hidden'] === null) element.removeAttribute('aria-hidden')\n  else element.setAttribute('aria-hidden', original['aria-hidden'])\n  // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n  element.inert = original.inert\n}\n\nexport function useInertOthers<TElement extends HTMLElement>(\n  container: MutableRefObject<TElement | null>,\n  enabled: boolean = true\n) {\n  useIsoMorphicEffect(() => {\n    if (!enabled) return\n    if (!container.current) return\n\n    let element = container.current\n\n    // Mark myself as an interactable element\n    interactables.add(element)\n\n    // Restore elements that now contain an interactable child\n    for (let original of originals.keys()) {\n      if (original.contains(element)) {\n        restore(original)\n        originals.delete(original)\n      }\n    }\n\n    // Collect direct children of the body\n    document.querySelectorAll('body > *').forEach(child => {\n      if (!(child instanceof HTMLElement)) return // Skip non-HTMLElements\n\n      // Skip the interactables, and the parents of the interactables\n      for (let interactable of interactables) {\n        if (child.contains(interactable)) return\n      }\n\n      // Keep track of the elements\n      if (interactables.size === 1) {\n        originals.set(child, {\n          'aria-hidden': child.getAttribute('aria-hidden'),\n          // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n          inert: child.inert,\n        })\n\n        // Mutate the element\n        inert(child)\n      }\n    })\n\n    return () => {\n      // Inert is disabled on the current element\n      interactables.delete(element)\n\n      // We still have interactable elements, therefore this one and its parent\n      // will become inert as well.\n      if (interactables.size > 0) {\n        // Collect direct children of the body\n        document.querySelectorAll('body > *').forEach(child => {\n          if (!(child instanceof HTMLElement)) return // Skip non-HTMLElements\n\n          // Skip already inert parents\n          if (originals.has(child)) return\n\n          // Skip the interactables, and the parents of the interactables\n          for (let interactable of interactables) {\n            if (child.contains(interactable)) return\n          }\n\n          originals.set(child, {\n            'aria-hidden': child.getAttribute('aria-hidden'),\n            // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n            inert: child.inert,\n          })\n\n          // Mutate the element\n          inert(child)\n        })\n      } else {\n        for (let element of originals.keys()) {\n          // Restore\n          restore(element)\n\n          // Cleanup\n          originals.delete(element)\n        }\n      }\n    }\n  }, [enabled])\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n} from 'react'\n\nlet ForcePortalRootContext = createContext(false)\n\nexport function usePortalRoot() {\n  return useContext(ForcePortalRootContext)\n}\n\ninterface ForcePortalRootProps {\n  force: boolean\n  children: ReactNode\n}\n\nexport function ForcePortalRoot(props: ForcePortalRootProps) {\n  return (\n    <ForcePortalRootContext.Provider value={props.force}>\n      {props.children}\n    </ForcePortalRootContext.Provider>\n  )\n}\n","import React, {\n  Fragment,\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { Props } from '../../types'\nimport { render } from '../../utils/render'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { usePortalRoot } from '../../internal/portal-force-root'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\nfunction usePortalTarget(): HTMLElement | null {\n  let forceInRoot = usePortalRoot()\n  let groupTarget = useContext(PortalGroupContext)\n  let [target, setTarget] = useState(() => {\n    // Group context is used, but still null\n    if (!forceInRoot && groupTarget !== null) return null\n\n    // No group context is used, let's create a default portal root\n    if (typeof window === 'undefined') return null\n    let existingRoot = document.getElementById('headlessui-portal-root')\n    if (existingRoot) return existingRoot\n\n    let root = document.createElement('div')\n    root.setAttribute('id', 'headlessui-portal-root')\n    return document.body.appendChild(root)\n  })\n\n  useEffect(() => {\n    if (forceInRoot) return\n    if (groupTarget === null) return\n    setTarget(groupTarget.current)\n  }, [groupTarget, setTarget, forceInRoot])\n\n  return target\n}\n\n// ---\n\nlet DEFAULT_PORTAL_TAG = Fragment\ninterface PortalRenderPropArg {}\n\nexport function Portal<TTag extends ElementType = typeof DEFAULT_PORTAL_TAG>(\n  props: Props<TTag, PortalRenderPropArg>\n) {\n  let passthroughProps = props\n  let target = usePortalTarget()\n  let [element] = useState<HTMLDivElement | null>(() =>\n    typeof window === 'undefined' ? null : document.createElement('div')\n  )\n\n  let ready = useServerHandoffComplete()\n\n  useIsoMorphicEffect(() => {\n    if (!target) return\n    if (!element) return\n\n    target.appendChild(element)\n\n    return () => {\n      if (!target) return\n      if (!element) return\n\n      target.removeChild(element)\n\n      if (target.childNodes.length <= 0) {\n        target.parentElement?.removeChild(target)\n      }\n    }\n  }, [target, element])\n\n  if (!ready) return null\n\n  return !target || !element\n    ? null\n    : createPortal(\n        render({ props: passthroughProps, defaultTag: DEFAULT_PORTAL_TAG, name: 'Portal' }),\n        element\n      )\n}\n\n// ---\n\nlet DEFAULT_GROUP_TAG = Fragment\ninterface GroupRenderPropArg {}\n\nlet PortalGroupContext = createContext<MutableRefObject<HTMLElement | null> | null>(null)\n\nfunction Group<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n  props: Props<TTag, GroupRenderPropArg> & {\n    target: MutableRefObject<HTMLElement | null>\n  }\n) {\n  let { target, ...passthroughProps } = props\n\n  return (\n    <PortalGroupContext.Provider value={target}>\n      {render({\n        props: passthroughProps,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n    </PortalGroupContext.Provider>\n  )\n}\n\n// ---\n\nPortal.Group = Group\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n\n  // Types\n  MutableRefObject,\n  ReactNode,\n} from 'react'\nimport { useIsoMorphicEffect } from '../hooks/use-iso-morphic-effect'\n\ntype OnUpdate = (\n  message: StackMessage,\n  type: string,\n  element: MutableRefObject<HTMLElement | null>\n) => void\n\nlet StackContext = createContext<OnUpdate>(() => {})\nStackContext.displayName = 'StackContext'\n\nexport enum StackMessage {\n  Add,\n  Remove,\n}\n\nexport function useStackContext() {\n  return useContext(StackContext)\n}\n\nexport function StackProvider({\n  children,\n  onUpdate,\n  type,\n  element,\n}: {\n  children: ReactNode\n  onUpdate?: OnUpdate\n  type: string\n  element: MutableRefObject<HTMLElement | null>\n}) {\n  let parentUpdate = useStackContext()\n\n  let notify = useCallback(\n    (...args: Parameters<OnUpdate>) => {\n      // Notify our layer\n      onUpdate?.(...args)\n\n      // Notify the parent\n      parentUpdate(...args)\n    },\n    [parentUpdate, onUpdate]\n  )\n\n  useIsoMorphicEffect(() => {\n    notify(StackMessage.Add, type, element)\n    return () => notify(StackMessage.Remove, type, element)\n  }, [notify, type, element])\n\n  return <StackContext.Provider value={notify}>{children}</StackContext.Provider>\n}\n","// WAI-ARIA: https://www.w3.org/TR/wai-aria-practices-1.2/#dialog_modal\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  // Types\n  ContextType,\n  ElementType,\n  MouseEvent as ReactMouseEvent,\n  MutableRefObject,\n  Ref,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { useId } from '../../hooks/use-id'\nimport { useFocusTrap, Features as FocusTrapFeatures } from '../../hooks/use-focus-trap'\nimport { useInertOthers } from '../../hooks/use-inert-others'\nimport { Portal } from '../../components/portal/portal'\nimport { ForcePortalRoot } from '../../internal/portal-force-root'\nimport { Description, useDescriptions } from '../description/description'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { useOpenClosed, State } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { StackProvider, StackMessage } from '../../internal/stack-context'\n\nenum DialogStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  titleId: string | null\n}\n\nenum ActionTypes {\n  SetTitleId,\n}\n\ntype Actions = { type: ActionTypes.SetTitleId; id: string | null }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.SetTitleId](state, action) {\n    if (state.titleId === action.id) return state\n    return { ...state, titleId: action.id }\n  },\n}\n\nlet DialogContext = createContext<\n  | [\n      {\n        dialogState: DialogStates\n        close(): void\n        setTitleId(id: string | null): void\n      },\n      StateDefinition\n    ]\n  | null\n>(null)\nDialogContext.displayName = 'DialogContext'\n\nfunction useDialogContext(component: string) {\n  let context = useContext(DialogContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Dialog.displayName} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDialogContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_DIALOG_TAG = 'div' as const\ninterface DialogRenderPropArg {\n  open: boolean\n}\ntype DialogPropsWeControl =\n  | 'id'\n  | 'role'\n  | 'aria-modal'\n  | 'aria-describedby'\n  | 'aria-labelledby'\n  | 'onClick'\n\nlet DialogRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet DialogRoot = forwardRefWithAs(function Dialog<\n  TTag extends ElementType = typeof DEFAULT_DIALOG_TAG\n>(\n  props: Props<TTag, DialogRenderPropArg, DialogPropsWeControl> &\n    PropsForFeatures<typeof DialogRenderFeatures> & {\n      open?: boolean\n      onClose(value: boolean): void\n      initialFocus?: MutableRefObject<HTMLElement | null>\n    },\n  ref: Ref<HTMLDivElement>\n) {\n  let { open, onClose, initialFocus, ...rest } = props\n  let [nestedDialogCount, setNestedDialogCount] = useState(0)\n\n  let usesOpenClosedState = useOpenClosed()\n  if (open === undefined && usesOpenClosedState !== null) {\n    // Update the `open` prop based on the open closed state\n    open = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  let containers = useRef<Set<MutableRefObject<HTMLElement | null>>>(new Set())\n  let internalDialogRef = useRef<HTMLDivElement | null>(null)\n  let dialogRef = useSyncRefs(internalDialogRef, ref)\n\n  // Validations\n  let hasOpen = props.hasOwnProperty('open') || usesOpenClosedState !== null\n  let hasOnClose = props.hasOwnProperty('onClose')\n  if (!hasOpen && !hasOnClose) {\n    throw new Error(\n      `You have to provide an \\`open\\` and an \\`onClose\\` prop to the \\`Dialog\\` component.`\n    )\n  }\n\n  if (!hasOpen) {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but forgot an \\`open\\` prop.`\n    )\n  }\n\n  if (!hasOnClose) {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but forgot an \\`onClose\\` prop.`\n    )\n  }\n\n  if (typeof open !== 'boolean') {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${open}`\n    )\n  }\n\n  if (typeof onClose !== 'function') {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${onClose}`\n    )\n  }\n  let dialogState = open ? DialogStates.Open : DialogStates.Closed\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return dialogState === DialogStates.Open\n  })()\n\n  let [state, dispatch] = useReducer(stateReducer, {\n    titleId: null,\n    descriptionId: null,\n  } as StateDefinition)\n\n  let close = useCallback(() => onClose(false), [onClose])\n\n  let setTitleId = useCallback(\n    (id: string | null) => dispatch({ type: ActionTypes.SetTitleId, id }),\n    [dispatch]\n  )\n\n  let ready = useServerHandoffComplete()\n  let enabled = ready && dialogState === DialogStates.Open\n  let hasNestedDialogs = nestedDialogCount > 1 // 1 is the current dialog\n  let hasParentDialog = useContext(DialogContext) !== null\n\n  // If there are multiple dialogs, then you can be the root, the leaf or one\n  // in between. We only care abou whether you are the top most one or not.\n  let position = !hasNestedDialogs ? 'leaf' : 'parent'\n\n  useFocusTrap(\n    internalDialogRef,\n    enabled\n      ? match(position, {\n          parent: FocusTrapFeatures.RestoreFocus,\n          leaf: FocusTrapFeatures.All,\n        })\n      : FocusTrapFeatures.None,\n    { initialFocus, containers }\n  )\n  useInertOthers(internalDialogRef, hasNestedDialogs ? enabled : false)\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (dialogState !== DialogStates.Open) return\n    if (hasNestedDialogs) return\n    if (internalDialogRef.current?.contains(target)) return\n\n    close()\n  })\n\n  // Handle `Escape` to close\n  useWindowEvent('keydown', event => {\n    if (event.key !== Keys.Escape) return\n    if (dialogState !== DialogStates.Open) return\n    if (hasNestedDialogs) return\n    event.preventDefault()\n    event.stopPropagation()\n    close()\n  })\n\n  // Scroll lock\n  useEffect(() => {\n    if (dialogState !== DialogStates.Open) return\n    if (hasParentDialog) return\n\n    let overflow = document.documentElement.style.overflow\n    let paddingRight = document.documentElement.style.paddingRight\n\n    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth\n\n    document.documentElement.style.overflow = 'hidden'\n    document.documentElement.style.paddingRight = `${scrollbarWidth}px`\n\n    return () => {\n      document.documentElement.style.overflow = overflow\n      document.documentElement.style.paddingRight = paddingRight\n    }\n  }, [dialogState, hasParentDialog])\n\n  // Trigger close when the FocusTrap gets hidden\n  useEffect(() => {\n    if (dialogState !== DialogStates.Open) return\n    if (!internalDialogRef.current) return\n\n    let observer = new IntersectionObserver(entries => {\n      for (let entry of entries) {\n        if (\n          entry.boundingClientRect.x === 0 &&\n          entry.boundingClientRect.y === 0 &&\n          entry.boundingClientRect.width === 0 &&\n          entry.boundingClientRect.height === 0\n        ) {\n          close()\n        }\n      }\n    })\n\n    observer.observe(internalDialogRef.current)\n\n    return () => observer.disconnect()\n  }, [dialogState, internalDialogRef, close])\n\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let id = `headlessui-dialog-${useId()}`\n\n  let contextBag = useMemo<ContextType<typeof DialogContext>>(\n    () => [{ dialogState, close, setTitleId }, state],\n    [dialogState, state, close, setTitleId]\n  )\n\n  let slot = useMemo<DialogRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n\n  let propsWeControl = {\n    ref: dialogRef,\n    id,\n    role: 'dialog',\n    'aria-modal': dialogState === DialogStates.Open ? true : undefined,\n    'aria-labelledby': state.titleId,\n    'aria-describedby': describedby,\n    onClick(event: ReactMouseEvent) {\n      event.stopPropagation()\n    },\n  }\n  let passthroughProps = rest\n\n  return (\n    <StackProvider\n      type=\"Dialog\"\n      element={internalDialogRef}\n      onUpdate={useCallback((message, type, element) => {\n        if (type !== 'Dialog') return\n\n        match(message, {\n          [StackMessage.Add]() {\n            containers.current.add(element)\n            setNestedDialogCount(count => count + 1)\n          },\n          [StackMessage.Remove]() {\n            containers.current.add(element)\n            setNestedDialogCount(count => count - 1)\n          },\n        })\n      }, [])}\n    >\n      <ForcePortalRoot force={true}>\n        <Portal>\n          <DialogContext.Provider value={contextBag}>\n            <Portal.Group target={internalDialogRef}>\n              <ForcePortalRoot force={false}>\n                <DescriptionProvider slot={slot} name=\"Dialog.Description\">\n                  {render({\n                    props: { ...passthroughProps, ...propsWeControl },\n                    slot,\n                    defaultTag: DEFAULT_DIALOG_TAG,\n                    features: DialogRenderFeatures,\n                    visible,\n                    name: 'Dialog',\n                  })}\n                </DescriptionProvider>\n              </ForcePortalRoot>\n            </Portal.Group>\n          </DialogContext.Provider>\n        </Portal>\n      </ForcePortalRoot>\n    </StackProvider>\n  )\n})\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ninterface OverlayRenderPropArg {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'id' | 'aria-hidden' | 'onClick'\n\nlet Overlay = forwardRefWithAs(function Overlay<\n  TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG\n>(props: Props<TTag, OverlayRenderPropArg, OverlayPropsWeControl>, ref: Ref<HTMLDivElement>) {\n  let [{ dialogState, close }] = useDialogContext([Dialog.displayName, Overlay.name].join('.'))\n  let overlayRef = useSyncRefs(ref)\n\n  let id = `headlessui-dialog-overlay-${useId()}`\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (event.target !== event.currentTarget) return\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      event.preventDefault()\n      event.stopPropagation()\n      close()\n    },\n    [close]\n  )\n\n  let slot = useMemo<OverlayRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n  let propsWeControl = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    name: 'Dialog.Overlay',\n  })\n})\n\n// ---\n\nlet DEFAULT_TITLE_TAG = 'h2' as const\ninterface TitleRenderPropArg {\n  open: boolean\n}\ntype TitlePropsWeControl = 'id'\n\nfunction Title<TTag extends ElementType = typeof DEFAULT_TITLE_TAG>(\n  props: Props<TTag, TitleRenderPropArg, TitlePropsWeControl>\n) {\n  let [{ dialogState, setTitleId }] = useDialogContext([Dialog.displayName, Title.name].join('.'))\n\n  let id = `headlessui-dialog-title-${useId()}`\n\n  useEffect(() => {\n    setTitleId(id)\n    return () => setTitleId(null)\n  }, [id, setTitleId])\n\n  let slot = useMemo<TitleRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n  let propsWeControl = { id }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_TITLE_TAG,\n    name: 'Dialog.Title',\n  })\n}\n\n// ---\n\nexport let Dialog = Object.assign(DialogRoot, { Overlay, Title, Description })\n","// WAI-ARIA: https://www.w3.org/TR/wai-aria-practices-1.2/#disclosure\nimport React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n\n  // Types\n  Dispatch,\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  Ref,\n  MutableRefObject,\n  ContextType,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useId } from '../../hooks/use-id'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\n\nenum DisclosureStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  disclosureState: DisclosureStates\n\n  linkedPanel: boolean\n\n  buttonId: string\n  panelId: string\n}\n\nenum ActionTypes {\n  ToggleDisclosure,\n  CloseDisclosure,\n\n  SetButtonId,\n  SetPanelId,\n\n  LinkPanel,\n  UnlinkPanel,\n}\n\ntype Actions =\n  | { type: ActionTypes.ToggleDisclosure }\n  | { type: ActionTypes.CloseDisclosure }\n  | { type: ActionTypes.SetButtonId; buttonId: string }\n  | { type: ActionTypes.SetPanelId; panelId: string }\n  | { type: ActionTypes.LinkPanel }\n  | { type: ActionTypes.UnlinkPanel }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.ToggleDisclosure]: state => ({\n    ...state,\n    disclosureState: match(state.disclosureState, {\n      [DisclosureStates.Open]: DisclosureStates.Closed,\n      [DisclosureStates.Closed]: DisclosureStates.Open,\n    }),\n  }),\n  [ActionTypes.CloseDisclosure]: state => {\n    if (state.disclosureState === DisclosureStates.Closed) return state\n    return { ...state, disclosureState: DisclosureStates.Closed }\n  },\n  [ActionTypes.LinkPanel](state) {\n    if (state.linkedPanel === true) return state\n    return { ...state, linkedPanel: true }\n  },\n  [ActionTypes.UnlinkPanel](state) {\n    if (state.linkedPanel === false) return state\n    return { ...state, linkedPanel: false }\n  },\n  [ActionTypes.SetButtonId](state, action) {\n    if (state.buttonId === action.buttonId) return state\n    return { ...state, buttonId: action.buttonId }\n  },\n  [ActionTypes.SetPanelId](state, action) {\n    if (state.panelId === action.panelId) return state\n    return { ...state, panelId: action.panelId }\n  },\n}\n\nlet DisclosureContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nDisclosureContext.displayName = 'DisclosureContext'\n\nfunction useDisclosureContext(component: string) {\n  let context = useContext(DisclosureContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Disclosure.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDisclosureContext)\n    throw err\n  }\n  return context\n}\n\nlet DisclosureAPIContext = createContext<{\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n} | null>(null)\nDisclosureAPIContext.displayName = 'DisclosureAPIContext'\n\nfunction useDisclosureAPIContext(component: string) {\n  let context = useContext(DisclosureAPIContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Disclosure.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDisclosureAPIContext)\n    throw err\n  }\n  return context\n}\n\nlet DisclosurePanelContext = createContext<string | null>(null)\nDisclosurePanelContext.displayName = 'DisclosurePanelContext'\n\nfunction useDisclosurePanelContext() {\n  return useContext(DisclosurePanelContext)\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_DISCLOSURE_TAG = Fragment\ninterface DisclosureRenderPropArg {\n  open: boolean\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n}\n\nexport function Disclosure<TTag extends ElementType = typeof DEFAULT_DISCLOSURE_TAG>(\n  props: Props<TTag, DisclosureRenderPropArg> & {\n    defaultOpen?: boolean\n  }\n) {\n  let { defaultOpen = false, ...passthroughProps } = props\n  let buttonId = `headlessui-disclosure-button-${useId()}`\n  let panelId = `headlessui-disclosure-panel-${useId()}`\n\n  let reducerBag = useReducer(stateReducer, {\n    disclosureState: defaultOpen ? DisclosureStates.Open : DisclosureStates.Closed,\n    linkedPanel: false,\n    buttonId,\n    panelId,\n  } as StateDefinition)\n  let [{ disclosureState }, dispatch] = reducerBag\n\n  useEffect(() => dispatch({ type: ActionTypes.SetButtonId, buttonId }), [buttonId, dispatch])\n  useEffect(() => dispatch({ type: ActionTypes.SetPanelId, panelId }), [panelId, dispatch])\n\n  let close = useCallback(\n    (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => {\n      dispatch({ type: ActionTypes.CloseDisclosure })\n\n      let restoreElement = (() => {\n        if (!focusableElement) return document.getElementById(buttonId)\n        if (focusableElement instanceof HTMLElement) return focusableElement\n        if (focusableElement.current instanceof HTMLElement) return focusableElement.current\n\n        return document.getElementById(buttonId)\n      })()\n\n      restoreElement?.focus()\n    },\n    [dispatch, buttonId]\n  )\n\n  let api = useMemo<ContextType<typeof DisclosureAPIContext>>(() => ({ close }), [close])\n\n  let slot = useMemo<DisclosureRenderPropArg>(\n    () => ({ open: disclosureState === DisclosureStates.Open, close }),\n    [disclosureState, close]\n  )\n\n  return (\n    <DisclosureContext.Provider value={reducerBag}>\n      <DisclosureAPIContext.Provider value={api}>\n        <OpenClosedProvider\n          value={match(disclosureState, {\n            [DisclosureStates.Open]: State.Open,\n            [DisclosureStates.Closed]: State.Closed,\n          })}\n        >\n          {render({\n            props: passthroughProps,\n            slot,\n            defaultTag: DEFAULT_DISCLOSURE_TAG,\n            name: 'Disclosure',\n          })}\n        </OpenClosedProvider>\n      </DisclosureAPIContext.Provider>\n    </DisclosureContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ninterface ButtonRenderPropArg {\n  open: boolean\n}\ntype ButtonPropsWeControl =\n  | 'id'\n  | 'type'\n  | 'aria-expanded'\n  | 'aria-controls'\n  | 'onKeyDown'\n  | 'onClick'\n\nlet Button = forwardRefWithAs(function Button<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: Props<TTag, ButtonRenderPropArg, ButtonPropsWeControl>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let [state, dispatch] = useDisclosureContext([Disclosure.name, Button.name].join('.'))\n  let internalButtonRef = useRef<HTMLButtonElement | null>(null)\n  let buttonRef = useSyncRefs(internalButtonRef, ref)\n\n  let panelContext = useDisclosurePanelContext()\n  let isWithinPanel = panelContext === null ? false : panelContext === state.panelId\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      if (isWithinPanel) {\n        if (state.disclosureState === DisclosureStates.Closed) return\n\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault()\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ToggleDisclosure })\n            document.getElementById(state.buttonId)?.focus()\n            break\n        }\n      } else {\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault()\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ToggleDisclosure })\n            break\n        }\n      }\n    },\n    [dispatch, isWithinPanel, state.disclosureState]\n  )\n\n  let handleKeyUp = useCallback((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  }, [])\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return\n      if (props.disabled) return\n\n      if (isWithinPanel) {\n        dispatch({ type: ActionTypes.ToggleDisclosure })\n        document.getElementById(state.buttonId)?.focus()\n      } else {\n        dispatch({ type: ActionTypes.ToggleDisclosure })\n      }\n    },\n    [dispatch, props.disabled, state.buttonId, isWithinPanel]\n  )\n\n  let slot = useMemo<ButtonRenderPropArg>(\n    () => ({ open: state.disclosureState === DisclosureStates.Open }),\n    [state]\n  )\n\n  let type = useResolveButtonType(props, internalButtonRef)\n  let passthroughProps = props\n  let propsWeControl = isWithinPanel\n    ? { ref: buttonRef, type, onKeyDown: handleKeyDown, onClick: handleClick }\n    : {\n        ref: buttonRef,\n        id: state.buttonId,\n        type,\n        'aria-expanded': props.disabled\n          ? undefined\n          : state.disclosureState === DisclosureStates.Open,\n        'aria-controls': state.linkedPanel ? state.panelId : undefined,\n        onKeyDown: handleKeyDown,\n        onKeyUp: handleKeyUp,\n        onClick: handleClick,\n      }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Disclosure.Button',\n  })\n})\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ninterface PanelRenderPropArg {\n  open: boolean\n  close: (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => void\n}\ntype PanelPropsWeControl = 'id'\n\nlet PanelRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Panel = forwardRefWithAs(function Panel<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: Props<TTag, PanelRenderPropArg, PanelPropsWeControl> &\n    PropsForFeatures<typeof PanelRenderFeatures>,\n  ref: Ref<HTMLDivElement>\n) {\n  let [state, dispatch] = useDisclosureContext([Disclosure.name, Panel.name].join('.'))\n  let { close } = useDisclosureAPIContext([Disclosure.name, Panel.name].join('.'))\n\n  let panelRef = useSyncRefs(ref, () => {\n    if (state.linkedPanel) return\n    dispatch({ type: ActionTypes.LinkPanel })\n  })\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return state.disclosureState === DisclosureStates.Open\n  })()\n\n  // Unlink on \"unmount\" myself\n  useEffect(() => () => dispatch({ type: ActionTypes.UnlinkPanel }), [dispatch])\n\n  // Unlink on \"unmount\" children\n  useEffect(() => {\n    if (state.disclosureState === DisclosureStates.Closed && (props.unmount ?? true)) {\n      dispatch({ type: ActionTypes.UnlinkPanel })\n    }\n  }, [state.disclosureState, props.unmount, dispatch])\n\n  let slot = useMemo<PanelRenderPropArg>(\n    () => ({ open: state.disclosureState === DisclosureStates.Open, close }),\n    [state, close]\n  )\n  let propsWeControl = {\n    ref: panelRef,\n    id: state.panelId,\n  }\n  let passthroughProps = props\n\n  return (\n    <DisclosurePanelContext.Provider value={state.panelId}>\n      {render({\n        props: { ...passthroughProps, ...propsWeControl },\n        slot,\n        defaultTag: DEFAULT_PANEL_TAG,\n        features: PanelRenderFeatures,\n        visible,\n        name: 'Disclosure.Panel',\n      })}\n    </DisclosurePanelContext.Provider>\n  )\n})\n\n// ---\n\nDisclosure.Button = Button\nDisclosure.Panel = Panel\n"],"sourceRoot":""}