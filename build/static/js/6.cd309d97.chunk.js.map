{"version":3,"sources":["../node_modules/lodash/map.js","../node_modules/lodash/_baseForOwn.js","../node_modules/lodash/_baseMap.js","../node_modules/lodash/_baseEach.js","../node_modules/lodash/_createBaseEach.js","../node_modules/lodash/_baseFor.js","../node_modules/lodash/_createBaseFor.js","../../../src/hooks/use-tree-walker.ts","../../../src/hooks/use-focus-trap.ts","../../../src/hooks/use-inert-others.ts","../../../src/internal/portal-force-root.tsx","../../../../src/components/portal/portal.tsx","../../../src/internal/stack-context.tsx","../../../../src/components/dialog/dialog.tsx","../../../../src/components/menu/menu.tsx","../../../../src/components/radio-group/radio-group.tsx","../../../src/hooks/use-flags.ts"],"names":["arrayMap","require","baseIteratee","baseMap","isArray","module","exports","collection","iteratee","baseFor","keys","object","baseEach","isArrayLike","index","result","Array","length","value","key","baseForOwn","createBaseEach","eachFunc","fromRight","iterable","Object","createBaseFor","keysFunc","props","useTreeWalker","container","accept","walk","enabled","acceptRef","useRef","walkRef","useEffect","useIsoMorphicEffect","acceptNode","walker","document","NodeFilter","Features","useFocusTrap","features","All","initialFocus","containers","restoreElement","window","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","featuresInitialFocus","focusElement","activeElement","focusIn","Focus","FocusResult","console","useWindowEvent","event","Keys","allContainers","Set","previous","toElement","contains","interactables","originals","inert","element","restore","original","ForcePortalRootContext","createContext","ForcePortalRoot","force","usePortalTarget","forceInRoot","useContext","groupTarget","useState","existingRoot","root","target","setTarget","DEFAULT_PORTAL_TAG","Portal","passthroughProps","ready","useServerHandoffComplete","createPortal","render","defaultTag","name","DEFAULT_GROUP_TAG","PortalGroupContext","StackMessage","StackContext","StackProvider","children","onUpdate","type","parentUpdate","notify","useCallback","args","DialogStates","ActionTypes","reducers","state","action","titleId","id","DialogContext","useDialogContext","component","context","err","Error","Dialog","stateReducer","match","DialogRenderFeatures","DialogRoot","forwardRefWithAs","open","onClose","rest","nestedDialogCount","setNestedDialogCount","usesOpenClosedState","useOpenClosed","State","internalDialogRef","dialogRef","useSyncRefs","hasOpen","hasOnClose","dialogState","visible","useReducer","descriptionId","dispatch","close","setTitleId","hasNestedDialogs","hasParentDialog","position","parent","FocusTrapFeatures","leaf","child","interactable","useInertOthers","overflow","paddingRight","scrollbarWidth","observer","IntersectionObserver","entries","entry","useDescriptions","describedby","DescriptionProvider","useId","contextBag","useMemo","slot","Open","propsWeControl","ref","role","onClick","message","count","React","Overlay","overlayRef","handleClick","isDisabledReactIssue7711","Title","Description","MenuStates","activeItemIndex","menuState","Closed","calculateActiveIndex","resolveItems","resolveActiveIndex","resolveId","item","resolveDisabled","searchQuery","items","dataRef","nextItems","currentActiveItem","idx","a","MenuContext","useMenuContext","Menu","DEFAULT_MENU_TAG","reducerBag","buttonRef","createRef","itemsRef","CloseMenu","isFocusableElement","FocusableMode","Button","d","useDisposables","handleKeyDown","OpenMenu","focus","First","Last","handleKeyUp","preventScroll","useResolveButtonType","onKeyDown","onKeyUp","ItemsRenderFeatures","Items","searchDisposables","node","disposables","Next","Previous","ClearSearch","tabIndex","DEFAULT_ITEM_TAG","Item","disabled","active","block","bag","handleFocus","Nothing","handleMove","handleLeave","onFocus","onPointerMove","onMouseMove","onPointerLeave","onMouseLeave","options","propsRef","radio","RadioGroupContext","useRadioGroupContext","RadioGroup","onChange","passThroughProps","useLabels","labelledby","LabelProvider","radioGroupRef","firstOption","option","containsCheckedOption","triggerChange","nextValue","nextOption","all","activeOption","registerOption","RegisterOption","api","change","OptionState","Option","optionRef","initialFlags","flags","setFlags","addFlag","hasFlag","removeFlag","toggleFlag","useFlags","radioGroupDisabled","radioGroupValue","handleBlur","isFirstOption","isDisabled","checked","undefined","onBlur"],"mappings":"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","file":"static/js/6.cd309d97.chunk.js","sourcesContent":["var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","import { useRef, useEffect } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\ntype AcceptNode = (\n  node: HTMLElement\n) =>\n  | typeof NodeFilter.FILTER_ACCEPT\n  | typeof NodeFilter.FILTER_SKIP\n  | typeof NodeFilter.FILTER_REJECT\n\nexport function useTreeWalker({\n  container,\n  accept,\n  walk,\n  enabled = true,\n}: {\n  container: HTMLElement | null\n  accept: AcceptNode\n  walk(node: HTMLElement): void\n  enabled?: boolean\n}) {\n  let acceptRef = useRef(accept)\n  let walkRef = useRef(walk)\n\n  useEffect(() => {\n    acceptRef.current = accept\n    walkRef.current = walk\n  }, [accept, walk])\n\n  useIsoMorphicEffect(() => {\n    if (!container) return\n    if (!enabled) return\n\n    let accept = acceptRef.current\n    let walk = walkRef.current\n\n    let acceptNode = Object.assign((node: HTMLElement) => accept(node), { acceptNode: accept })\n    let walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, acceptNode, false)\n\n    while (walker.nextNode()) walk(walker.currentNode as HTMLElement)\n  }, [container, enabled, acceptRef, walkRef])\n}\n","import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n","import { MutableRefObject } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nlet interactables = new Set<HTMLElement>()\nlet originals = new Map<HTMLElement, { 'aria-hidden': string | null; inert: boolean }>()\n\nfunction inert(element: HTMLElement) {\n  element.setAttribute('aria-hidden', 'true')\n  // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n  element.inert = true\n}\n\nfunction restore(element: HTMLElement) {\n  let original = originals.get(element)\n  if (!original) return\n\n  if (original['aria-hidden'] === null) element.removeAttribute('aria-hidden')\n  else element.setAttribute('aria-hidden', original['aria-hidden'])\n  // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n  element.inert = original.inert\n}\n\nexport function useInertOthers<TElement extends HTMLElement>(\n  container: MutableRefObject<TElement | null>,\n  enabled: boolean = true\n) {\n  useIsoMorphicEffect(() => {\n    if (!enabled) return\n    if (!container.current) return\n\n    let element = container.current\n\n    // Mark myself as an interactable element\n    interactables.add(element)\n\n    // Restore elements that now contain an interactable child\n    for (let original of originals.keys()) {\n      if (original.contains(element)) {\n        restore(original)\n        originals.delete(original)\n      }\n    }\n\n    // Collect direct children of the body\n    document.querySelectorAll('body > *').forEach(child => {\n      if (!(child instanceof HTMLElement)) return // Skip non-HTMLElements\n\n      // Skip the interactables, and the parents of the interactables\n      for (let interactable of interactables) {\n        if (child.contains(interactable)) return\n      }\n\n      // Keep track of the elements\n      if (interactables.size === 1) {\n        originals.set(child, {\n          'aria-hidden': child.getAttribute('aria-hidden'),\n          // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n          inert: child.inert,\n        })\n\n        // Mutate the element\n        inert(child)\n      }\n    })\n\n    return () => {\n      // Inert is disabled on the current element\n      interactables.delete(element)\n\n      // We still have interactable elements, therefore this one and its parent\n      // will become inert as well.\n      if (interactables.size > 0) {\n        // Collect direct children of the body\n        document.querySelectorAll('body > *').forEach(child => {\n          if (!(child instanceof HTMLElement)) return // Skip non-HTMLElements\n\n          // Skip already inert parents\n          if (originals.has(child)) return\n\n          // Skip the interactables, and the parents of the interactables\n          for (let interactable of interactables) {\n            if (child.contains(interactable)) return\n          }\n\n          originals.set(child, {\n            'aria-hidden': child.getAttribute('aria-hidden'),\n            // @ts-expect-error `inert` does not exist on HTMLElement (yet!)\n            inert: child.inert,\n          })\n\n          // Mutate the element\n          inert(child)\n        })\n      } else {\n        for (let element of originals.keys()) {\n          // Restore\n          restore(element)\n\n          // Cleanup\n          originals.delete(element)\n        }\n      }\n    }\n  }, [enabled])\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n} from 'react'\n\nlet ForcePortalRootContext = createContext(false)\n\nexport function usePortalRoot() {\n  return useContext(ForcePortalRootContext)\n}\n\ninterface ForcePortalRootProps {\n  force: boolean\n  children: ReactNode\n}\n\nexport function ForcePortalRoot(props: ForcePortalRootProps) {\n  return (\n    <ForcePortalRootContext.Provider value={props.force}>\n      {props.children}\n    </ForcePortalRootContext.Provider>\n  )\n}\n","import React, {\n  Fragment,\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { Props } from '../../types'\nimport { render } from '../../utils/render'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { usePortalRoot } from '../../internal/portal-force-root'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\nfunction usePortalTarget(): HTMLElement | null {\n  let forceInRoot = usePortalRoot()\n  let groupTarget = useContext(PortalGroupContext)\n  let [target, setTarget] = useState(() => {\n    // Group context is used, but still null\n    if (!forceInRoot && groupTarget !== null) return null\n\n    // No group context is used, let's create a default portal root\n    if (typeof window === 'undefined') return null\n    let existingRoot = document.getElementById('headlessui-portal-root')\n    if (existingRoot) return existingRoot\n\n    let root = document.createElement('div')\n    root.setAttribute('id', 'headlessui-portal-root')\n    return document.body.appendChild(root)\n  })\n\n  useEffect(() => {\n    if (forceInRoot) return\n    if (groupTarget === null) return\n    setTarget(groupTarget.current)\n  }, [groupTarget, setTarget, forceInRoot])\n\n  return target\n}\n\n// ---\n\nlet DEFAULT_PORTAL_TAG = Fragment\ninterface PortalRenderPropArg {}\n\nexport function Portal<TTag extends ElementType = typeof DEFAULT_PORTAL_TAG>(\n  props: Props<TTag, PortalRenderPropArg>\n) {\n  let passthroughProps = props\n  let target = usePortalTarget()\n  let [element] = useState<HTMLDivElement | null>(() =>\n    typeof window === 'undefined' ? null : document.createElement('div')\n  )\n\n  let ready = useServerHandoffComplete()\n\n  useIsoMorphicEffect(() => {\n    if (!target) return\n    if (!element) return\n\n    target.appendChild(element)\n\n    return () => {\n      if (!target) return\n      if (!element) return\n\n      target.removeChild(element)\n\n      if (target.childNodes.length <= 0) {\n        target.parentElement?.removeChild(target)\n      }\n    }\n  }, [target, element])\n\n  if (!ready) return null\n\n  return !target || !element\n    ? null\n    : createPortal(\n        render({ props: passthroughProps, defaultTag: DEFAULT_PORTAL_TAG, name: 'Portal' }),\n        element\n      )\n}\n\n// ---\n\nlet DEFAULT_GROUP_TAG = Fragment\ninterface GroupRenderPropArg {}\n\nlet PortalGroupContext = createContext<MutableRefObject<HTMLElement | null> | null>(null)\n\nfunction Group<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n  props: Props<TTag, GroupRenderPropArg> & {\n    target: MutableRefObject<HTMLElement | null>\n  }\n) {\n  let { target, ...passthroughProps } = props\n\n  return (\n    <PortalGroupContext.Provider value={target}>\n      {render({\n        props: passthroughProps,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n    </PortalGroupContext.Provider>\n  )\n}\n\n// ---\n\nPortal.Group = Group\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n\n  // Types\n  MutableRefObject,\n  ReactNode,\n} from 'react'\nimport { useIsoMorphicEffect } from '../hooks/use-iso-morphic-effect'\n\ntype OnUpdate = (\n  message: StackMessage,\n  type: string,\n  element: MutableRefObject<HTMLElement | null>\n) => void\n\nlet StackContext = createContext<OnUpdate>(() => {})\nStackContext.displayName = 'StackContext'\n\nexport enum StackMessage {\n  Add,\n  Remove,\n}\n\nexport function useStackContext() {\n  return useContext(StackContext)\n}\n\nexport function StackProvider({\n  children,\n  onUpdate,\n  type,\n  element,\n}: {\n  children: ReactNode\n  onUpdate?: OnUpdate\n  type: string\n  element: MutableRefObject<HTMLElement | null>\n}) {\n  let parentUpdate = useStackContext()\n\n  let notify = useCallback(\n    (...args: Parameters<OnUpdate>) => {\n      // Notify our layer\n      onUpdate?.(...args)\n\n      // Notify the parent\n      parentUpdate(...args)\n    },\n    [parentUpdate, onUpdate]\n  )\n\n  useIsoMorphicEffect(() => {\n    notify(StackMessage.Add, type, element)\n    return () => notify(StackMessage.Remove, type, element)\n  }, [notify, type, element])\n\n  return <StackContext.Provider value={notify}>{children}</StackContext.Provider>\n}\n","// WAI-ARIA: https://www.w3.org/TR/wai-aria-practices-1.2/#dialog_modal\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  // Types\n  ContextType,\n  ElementType,\n  MouseEvent as ReactMouseEvent,\n  MutableRefObject,\n  Ref,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { useId } from '../../hooks/use-id'\nimport { useFocusTrap, Features as FocusTrapFeatures } from '../../hooks/use-focus-trap'\nimport { useInertOthers } from '../../hooks/use-inert-others'\nimport { Portal } from '../../components/portal/portal'\nimport { ForcePortalRoot } from '../../internal/portal-force-root'\nimport { Description, useDescriptions } from '../description/description'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { useOpenClosed, State } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { StackProvider, StackMessage } from '../../internal/stack-context'\n\nenum DialogStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  titleId: string | null\n}\n\nenum ActionTypes {\n  SetTitleId,\n}\n\ntype Actions = { type: ActionTypes.SetTitleId; id: string | null }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.SetTitleId](state, action) {\n    if (state.titleId === action.id) return state\n    return { ...state, titleId: action.id }\n  },\n}\n\nlet DialogContext = createContext<\n  | [\n      {\n        dialogState: DialogStates\n        close(): void\n        setTitleId(id: string | null): void\n      },\n      StateDefinition\n    ]\n  | null\n>(null)\nDialogContext.displayName = 'DialogContext'\n\nfunction useDialogContext(component: string) {\n  let context = useContext(DialogContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Dialog.displayName} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDialogContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_DIALOG_TAG = 'div' as const\ninterface DialogRenderPropArg {\n  open: boolean\n}\ntype DialogPropsWeControl =\n  | 'id'\n  | 'role'\n  | 'aria-modal'\n  | 'aria-describedby'\n  | 'aria-labelledby'\n  | 'onClick'\n\nlet DialogRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet DialogRoot = forwardRefWithAs(function Dialog<\n  TTag extends ElementType = typeof DEFAULT_DIALOG_TAG\n>(\n  props: Props<TTag, DialogRenderPropArg, DialogPropsWeControl> &\n    PropsForFeatures<typeof DialogRenderFeatures> & {\n      open?: boolean\n      onClose(value: boolean): void\n      initialFocus?: MutableRefObject<HTMLElement | null>\n    },\n  ref: Ref<HTMLDivElement>\n) {\n  let { open, onClose, initialFocus, ...rest } = props\n  let [nestedDialogCount, setNestedDialogCount] = useState(0)\n\n  let usesOpenClosedState = useOpenClosed()\n  if (open === undefined && usesOpenClosedState !== null) {\n    // Update the `open` prop based on the open closed state\n    open = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  let containers = useRef<Set<MutableRefObject<HTMLElement | null>>>(new Set())\n  let internalDialogRef = useRef<HTMLDivElement | null>(null)\n  let dialogRef = useSyncRefs(internalDialogRef, ref)\n\n  // Validations\n  let hasOpen = props.hasOwnProperty('open') || usesOpenClosedState !== null\n  let hasOnClose = props.hasOwnProperty('onClose')\n  if (!hasOpen && !hasOnClose) {\n    throw new Error(\n      `You have to provide an \\`open\\` and an \\`onClose\\` prop to the \\`Dialog\\` component.`\n    )\n  }\n\n  if (!hasOpen) {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but forgot an \\`open\\` prop.`\n    )\n  }\n\n  if (!hasOnClose) {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but forgot an \\`onClose\\` prop.`\n    )\n  }\n\n  if (typeof open !== 'boolean') {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${open}`\n    )\n  }\n\n  if (typeof onClose !== 'function') {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${onClose}`\n    )\n  }\n  let dialogState = open ? DialogStates.Open : DialogStates.Closed\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return dialogState === DialogStates.Open\n  })()\n\n  let [state, dispatch] = useReducer(stateReducer, {\n    titleId: null,\n    descriptionId: null,\n  } as StateDefinition)\n\n  let close = useCallback(() => onClose(false), [onClose])\n\n  let setTitleId = useCallback(\n    (id: string | null) => dispatch({ type: ActionTypes.SetTitleId, id }),\n    [dispatch]\n  )\n\n  let ready = useServerHandoffComplete()\n  let enabled = ready && dialogState === DialogStates.Open\n  let hasNestedDialogs = nestedDialogCount > 1 // 1 is the current dialog\n  let hasParentDialog = useContext(DialogContext) !== null\n\n  // If there are multiple dialogs, then you can be the root, the leaf or one\n  // in between. We only care abou whether you are the top most one or not.\n  let position = !hasNestedDialogs ? 'leaf' : 'parent'\n\n  useFocusTrap(\n    internalDialogRef,\n    enabled\n      ? match(position, {\n          parent: FocusTrapFeatures.RestoreFocus,\n          leaf: FocusTrapFeatures.All,\n        })\n      : FocusTrapFeatures.None,\n    { initialFocus, containers }\n  )\n  useInertOthers(internalDialogRef, hasNestedDialogs ? enabled : false)\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (dialogState !== DialogStates.Open) return\n    if (hasNestedDialogs) return\n    if (internalDialogRef.current?.contains(target)) return\n\n    close()\n  })\n\n  // Handle `Escape` to close\n  useWindowEvent('keydown', event => {\n    if (event.key !== Keys.Escape) return\n    if (dialogState !== DialogStates.Open) return\n    if (hasNestedDialogs) return\n    event.preventDefault()\n    event.stopPropagation()\n    close()\n  })\n\n  // Scroll lock\n  useEffect(() => {\n    if (dialogState !== DialogStates.Open) return\n    if (hasParentDialog) return\n\n    let overflow = document.documentElement.style.overflow\n    let paddingRight = document.documentElement.style.paddingRight\n\n    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth\n\n    document.documentElement.style.overflow = 'hidden'\n    document.documentElement.style.paddingRight = `${scrollbarWidth}px`\n\n    return () => {\n      document.documentElement.style.overflow = overflow\n      document.documentElement.style.paddingRight = paddingRight\n    }\n  }, [dialogState, hasParentDialog])\n\n  // Trigger close when the FocusTrap gets hidden\n  useEffect(() => {\n    if (dialogState !== DialogStates.Open) return\n    if (!internalDialogRef.current) return\n\n    let observer = new IntersectionObserver(entries => {\n      for (let entry of entries) {\n        if (\n          entry.boundingClientRect.x === 0 &&\n          entry.boundingClientRect.y === 0 &&\n          entry.boundingClientRect.width === 0 &&\n          entry.boundingClientRect.height === 0\n        ) {\n          close()\n        }\n      }\n    })\n\n    observer.observe(internalDialogRef.current)\n\n    return () => observer.disconnect()\n  }, [dialogState, internalDialogRef, close])\n\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let id = `headlessui-dialog-${useId()}`\n\n  let contextBag = useMemo<ContextType<typeof DialogContext>>(\n    () => [{ dialogState, close, setTitleId }, state],\n    [dialogState, state, close, setTitleId]\n  )\n\n  let slot = useMemo<DialogRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n\n  let propsWeControl = {\n    ref: dialogRef,\n    id,\n    role: 'dialog',\n    'aria-modal': dialogState === DialogStates.Open ? true : undefined,\n    'aria-labelledby': state.titleId,\n    'aria-describedby': describedby,\n    onClick(event: ReactMouseEvent) {\n      event.stopPropagation()\n    },\n  }\n  let passthroughProps = rest\n\n  return (\n    <StackProvider\n      type=\"Dialog\"\n      element={internalDialogRef}\n      onUpdate={useCallback((message, type, element) => {\n        if (type !== 'Dialog') return\n\n        match(message, {\n          [StackMessage.Add]() {\n            containers.current.add(element)\n            setNestedDialogCount(count => count + 1)\n          },\n          [StackMessage.Remove]() {\n            containers.current.add(element)\n            setNestedDialogCount(count => count - 1)\n          },\n        })\n      }, [])}\n    >\n      <ForcePortalRoot force={true}>\n        <Portal>\n          <DialogContext.Provider value={contextBag}>\n            <Portal.Group target={internalDialogRef}>\n              <ForcePortalRoot force={false}>\n                <DescriptionProvider slot={slot} name=\"Dialog.Description\">\n                  {render({\n                    props: { ...passthroughProps, ...propsWeControl },\n                    slot,\n                    defaultTag: DEFAULT_DIALOG_TAG,\n                    features: DialogRenderFeatures,\n                    visible,\n                    name: 'Dialog',\n                  })}\n                </DescriptionProvider>\n              </ForcePortalRoot>\n            </Portal.Group>\n          </DialogContext.Provider>\n        </Portal>\n      </ForcePortalRoot>\n    </StackProvider>\n  )\n})\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ninterface OverlayRenderPropArg {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'id' | 'aria-hidden' | 'onClick'\n\nlet Overlay = forwardRefWithAs(function Overlay<\n  TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG\n>(props: Props<TTag, OverlayRenderPropArg, OverlayPropsWeControl>, ref: Ref<HTMLDivElement>) {\n  let [{ dialogState, close }] = useDialogContext([Dialog.displayName, Overlay.name].join('.'))\n  let overlayRef = useSyncRefs(ref)\n\n  let id = `headlessui-dialog-overlay-${useId()}`\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (event.target !== event.currentTarget) return\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      event.preventDefault()\n      event.stopPropagation()\n      close()\n    },\n    [close]\n  )\n\n  let slot = useMemo<OverlayRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n  let propsWeControl = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    name: 'Dialog.Overlay',\n  })\n})\n\n// ---\n\nlet DEFAULT_TITLE_TAG = 'h2' as const\ninterface TitleRenderPropArg {\n  open: boolean\n}\ntype TitlePropsWeControl = 'id'\n\nfunction Title<TTag extends ElementType = typeof DEFAULT_TITLE_TAG>(\n  props: Props<TTag, TitleRenderPropArg, TitlePropsWeControl>\n) {\n  let [{ dialogState, setTitleId }] = useDialogContext([Dialog.displayName, Title.name].join('.'))\n\n  let id = `headlessui-dialog-title-${useId()}`\n\n  useEffect(() => {\n    setTitleId(id)\n    return () => setTitleId(null)\n  }, [id, setTitleId])\n\n  let slot = useMemo<TitleRenderPropArg>(() => ({ open: dialogState === DialogStates.Open }), [\n    dialogState,\n  ])\n  let propsWeControl = { id }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_TITLE_TAG,\n    name: 'Dialog.Title',\n  })\n}\n\n// ---\n\nexport let Dialog = Object.assign(DialogRoot, { Overlay, Title, Description })\n","// WAI-ARIA: https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\nimport React, {\n  Fragment,\n  createContext,\n  createRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n\n  // Types\n  Dispatch,\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  MutableRefObject,\n  Ref,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { disposables } from '../../utils/disposables'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useId } from '../../hooks/use-id'\nimport { Keys } from '../keyboard'\nimport { Focus, calculateActiveIndex } from '../../utils/calculate-active-index'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { isFocusableElement, FocusableMode } from '../../utils/focus-management'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { useTreeWalker } from '../../hooks/use-tree-walker'\nimport { useOpenClosed, State, OpenClosedProvider } from '../../internal/open-closed'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\n\nenum MenuStates {\n  Open,\n  Closed,\n}\n\ntype MenuItemDataRef = MutableRefObject<{ textValue?: string; disabled: boolean }>\n\ninterface StateDefinition {\n  menuState: MenuStates\n  buttonRef: MutableRefObject<HTMLButtonElement | null>\n  itemsRef: MutableRefObject<HTMLDivElement | null>\n  items: { id: string; dataRef: MenuItemDataRef }[]\n  searchQuery: string\n  activeItemIndex: number | null\n}\n\nenum ActionTypes {\n  OpenMenu,\n  CloseMenu,\n\n  GoToItem,\n  Search,\n  ClearSearch,\n  RegisterItem,\n  UnregisterItem,\n}\n\ntype Actions =\n  | { type: ActionTypes.CloseMenu }\n  | { type: ActionTypes.OpenMenu }\n  | { type: ActionTypes.GoToItem; focus: Focus.Specific; id: string }\n  | { type: ActionTypes.GoToItem; focus: Exclude<Focus, Focus.Specific> }\n  | { type: ActionTypes.Search; value: string }\n  | { type: ActionTypes.ClearSearch }\n  | { type: ActionTypes.RegisterItem; id: string; dataRef: MenuItemDataRef }\n  | { type: ActionTypes.UnregisterItem; id: string }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.CloseMenu](state) {\n    if (state.menuState === MenuStates.Closed) return state\n    return { ...state, activeItemIndex: null, menuState: MenuStates.Closed }\n  },\n  [ActionTypes.OpenMenu](state) {\n    if (state.menuState === MenuStates.Open) return state\n    return { ...state, menuState: MenuStates.Open }\n  },\n  [ActionTypes.GoToItem]: (state, action) => {\n    let activeItemIndex = calculateActiveIndex(action, {\n      resolveItems: () => state.items,\n      resolveActiveIndex: () => state.activeItemIndex,\n      resolveId: item => item.id,\n      resolveDisabled: item => item.dataRef.current.disabled,\n    })\n\n    if (state.searchQuery === '' && state.activeItemIndex === activeItemIndex) return state\n    return { ...state, searchQuery: '', activeItemIndex }\n  },\n  [ActionTypes.Search]: (state, action) => {\n    let searchQuery = state.searchQuery + action.value.toLowerCase()\n    let match = state.items.findIndex(\n      item =>\n        item.dataRef.current.textValue?.startsWith(searchQuery) && !item.dataRef.current.disabled\n    )\n\n    if (match === -1 || match === state.activeItemIndex) return { ...state, searchQuery }\n    return { ...state, searchQuery, activeItemIndex: match }\n  },\n  [ActionTypes.ClearSearch](state) {\n    if (state.searchQuery === '') return state\n    return { ...state, searchQuery: '' }\n  },\n  [ActionTypes.RegisterItem]: (state, action) => ({\n    ...state,\n    items: [...state.items, { id: action.id, dataRef: action.dataRef }],\n  }),\n  [ActionTypes.UnregisterItem]: (state, action) => {\n    let nextItems = state.items.slice()\n    let currentActiveItem = state.activeItemIndex !== null ? nextItems[state.activeItemIndex] : null\n\n    let idx = nextItems.findIndex(a => a.id === action.id)\n\n    if (idx !== -1) nextItems.splice(idx, 1)\n\n    return {\n      ...state,\n      items: nextItems,\n      activeItemIndex: (() => {\n        if (idx === state.activeItemIndex) return null\n        if (currentActiveItem === null) return null\n\n        // If we removed the item before the actual active index, then it would be out of sync. To\n        // fix this, we will find the correct (new) index position.\n        return nextItems.indexOf(currentActiveItem)\n      })(),\n    }\n  },\n}\n\nlet MenuContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nMenuContext.displayName = 'MenuContext'\n\nfunction useMenuContext(component: string) {\n  let context = useContext(MenuContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Menu.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useMenuContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_MENU_TAG = Fragment\ninterface MenuRenderPropArg {\n  open: boolean\n}\n\nexport function Menu<TTag extends ElementType = typeof DEFAULT_MENU_TAG>(\n  props: Props<TTag, MenuRenderPropArg>\n) {\n  let reducerBag = useReducer(stateReducer, {\n    menuState: MenuStates.Closed,\n    buttonRef: createRef(),\n    itemsRef: createRef(),\n    items: [],\n    searchQuery: '',\n    activeItemIndex: null,\n  } as StateDefinition)\n  let [{ menuState, itemsRef, buttonRef }, dispatch] = reducerBag\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (menuState !== MenuStates.Open) return\n\n    if (buttonRef.current?.contains(target)) return\n    if (itemsRef.current?.contains(target)) return\n\n    dispatch({ type: ActionTypes.CloseMenu })\n\n    if (!isFocusableElement(target, FocusableMode.Loose)) {\n      event.preventDefault()\n      buttonRef.current?.focus()\n    }\n  })\n\n  let slot = useMemo<MenuRenderPropArg>(() => ({ open: menuState === MenuStates.Open }), [\n    menuState,\n  ])\n\n  return (\n    <MenuContext.Provider value={reducerBag}>\n      <OpenClosedProvider\n        value={match(menuState, {\n          [MenuStates.Open]: State.Open,\n          [MenuStates.Closed]: State.Closed,\n        })}\n      >\n        {render({ props, slot, defaultTag: DEFAULT_MENU_TAG, name: 'Menu' })}\n      </OpenClosedProvider>\n    </MenuContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ninterface ButtonRenderPropArg {\n  open: boolean\n}\ntype ButtonPropsWeControl =\n  | 'id'\n  | 'type'\n  | 'aria-haspopup'\n  | 'aria-controls'\n  | 'aria-expanded'\n  | 'onKeyDown'\n  | 'onClick'\n\nlet Button = forwardRefWithAs(function Button<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: Props<TTag, ButtonRenderPropArg, ButtonPropsWeControl>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let [state, dispatch] = useMenuContext([Menu.name, Button.name].join('.'))\n  let buttonRef = useSyncRefs(state.buttonRef, ref)\n\n  let id = `headlessui-menu-button-${useId()}`\n  let d = useDisposables()\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      switch (event.key) {\n        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-13\n\n        case Keys.Space:\n        case Keys.Enter:\n        case Keys.ArrowDown:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.OpenMenu })\n          d.nextFrame(() => dispatch({ type: ActionTypes.GoToItem, focus: Focus.First }))\n          break\n\n        case Keys.ArrowUp:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.OpenMenu })\n          d.nextFrame(() => dispatch({ type: ActionTypes.GoToItem, focus: Focus.Last }))\n          break\n      }\n    },\n    [dispatch, d]\n  )\n\n  let handleKeyUp = useCallback((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  }, [])\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      if (props.disabled) return\n      if (state.menuState === MenuStates.Open) {\n        dispatch({ type: ActionTypes.CloseMenu })\n        d.nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n      } else {\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.OpenMenu })\n      }\n    },\n    [dispatch, d, state, props.disabled]\n  )\n\n  let slot = useMemo<ButtonRenderPropArg>(() => ({ open: state.menuState === MenuStates.Open }), [\n    state,\n  ])\n  let passthroughProps = props\n  let propsWeControl = {\n    ref: buttonRef,\n    id,\n    type: useResolveButtonType(props, state.buttonRef),\n    'aria-haspopup': true,\n    'aria-controls': state.itemsRef.current?.id,\n    'aria-expanded': props.disabled ? undefined : state.menuState === MenuStates.Open,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick,\n  }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Menu.Button',\n  })\n})\n\n// ---\n\nlet DEFAULT_ITEMS_TAG = 'div' as const\ninterface ItemsRenderPropArg {\n  open: boolean\n}\ntype ItemsPropsWeControl =\n  | 'aria-activedescendant'\n  | 'aria-labelledby'\n  | 'id'\n  | 'onKeyDown'\n  | 'role'\n  | 'tabIndex'\n\nlet ItemsRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Items = forwardRefWithAs(function Items<TTag extends ElementType = typeof DEFAULT_ITEMS_TAG>(\n  props: Props<TTag, ItemsRenderPropArg, ItemsPropsWeControl> &\n    PropsForFeatures<typeof ItemsRenderFeatures>,\n  ref: Ref<HTMLDivElement>\n) {\n  let [state, dispatch] = useMenuContext([Menu.name, Items.name].join('.'))\n  let itemsRef = useSyncRefs(state.itemsRef, ref)\n\n  let id = `headlessui-menu-items-${useId()}`\n  let searchDisposables = useDisposables()\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return state.menuState === MenuStates.Open\n  })()\n\n  useEffect(() => {\n    let container = state.itemsRef.current\n    if (!container) return\n    if (state.menuState !== MenuStates.Open) return\n    if (container === document.activeElement) return\n\n    container.focus({ preventScroll: true })\n  }, [state.menuState, state.itemsRef])\n\n  useTreeWalker({\n    container: state.itemsRef.current,\n    enabled: state.menuState === MenuStates.Open,\n    accept(node) {\n      if (node.getAttribute('role') === 'menuitem') return NodeFilter.FILTER_REJECT\n      if (node.hasAttribute('role')) return NodeFilter.FILTER_SKIP\n      return NodeFilter.FILTER_ACCEPT\n    },\n    walk(node) {\n      node.setAttribute('role', 'none')\n    },\n  })\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLDivElement>) => {\n      searchDisposables.dispose()\n\n      switch (event.key) {\n        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-12\n\n        // @ts-expect-error Fallthrough is expected here\n        case Keys.Space:\n          if (state.searchQuery !== '') {\n            event.preventDefault()\n            event.stopPropagation()\n            return dispatch({ type: ActionTypes.Search, value: event.key })\n          }\n        // When in type ahead mode, fallthrough\n        case Keys.Enter:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.CloseMenu })\n          if (state.activeItemIndex !== null) {\n            let { id } = state.items[state.activeItemIndex]\n            document.getElementById(id)?.click()\n          }\n          disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n          break\n\n        case Keys.ArrowDown:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Next })\n\n        case Keys.ArrowUp:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Previous })\n\n        case Keys.Home:\n        case Keys.PageUp:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToItem, focus: Focus.First })\n\n        case Keys.End:\n        case Keys.PageDown:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Last })\n\n        case Keys.Escape:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.CloseMenu })\n          disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n          break\n\n        case Keys.Tab:\n          event.preventDefault()\n          event.stopPropagation()\n          break\n\n        default:\n          if (event.key.length === 1) {\n            dispatch({ type: ActionTypes.Search, value: event.key })\n            searchDisposables.setTimeout(() => dispatch({ type: ActionTypes.ClearSearch }), 350)\n          }\n          break\n      }\n    },\n    [dispatch, searchDisposables, state]\n  )\n\n  let handleKeyUp = useCallback((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  }, [])\n\n  let slot = useMemo<ItemsRenderPropArg>(() => ({ open: state.menuState === MenuStates.Open }), [\n    state,\n  ])\n  let propsWeControl = {\n    'aria-activedescendant':\n      state.activeItemIndex === null ? undefined : state.items[state.activeItemIndex]?.id,\n    'aria-labelledby': state.buttonRef.current?.id,\n    id,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    role: 'menu',\n    tabIndex: 0,\n    ref: itemsRef,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_ITEMS_TAG,\n    features: ItemsRenderFeatures,\n    visible,\n    name: 'Menu.Items',\n  })\n})\n\n// ---\n\nlet DEFAULT_ITEM_TAG = Fragment\ninterface ItemRenderPropArg {\n  active: boolean\n  disabled: boolean\n}\ntype MenuItemPropsWeControl =\n  | 'id'\n  | 'role'\n  | 'tabIndex'\n  | 'aria-disabled'\n  | 'onPointerLeave'\n  | 'onPointerMove'\n  | 'onMouseLeave'\n  | 'onMouseMove'\n  | 'onFocus'\n\nfunction Item<TTag extends ElementType = typeof DEFAULT_ITEM_TAG>(\n  props: Props<TTag, ItemRenderPropArg, MenuItemPropsWeControl> & {\n    disabled?: boolean\n    onClick?: (event: { preventDefault: Function }) => void\n  }\n) {\n  let { disabled = false, onClick, ...passthroughProps } = props\n  let [state, dispatch] = useMenuContext([Menu.name, Item.name].join('.'))\n  let id = `headlessui-menu-item-${useId()}`\n  let active = state.activeItemIndex !== null ? state.items[state.activeItemIndex].id === id : false\n\n  useIsoMorphicEffect(() => {\n    if (state.menuState !== MenuStates.Open) return\n    if (!active) return\n    let d = disposables()\n    d.nextFrame(() => document.getElementById(id)?.scrollIntoView?.({ block: 'nearest' }))\n    return d.dispose\n  }, [id, active, state.menuState])\n\n  let bag = useRef<MenuItemDataRef['current']>({ disabled })\n\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled\n  }, [bag, disabled])\n\n  useIsoMorphicEffect(() => {\n    bag.current.textValue = document.getElementById(id)?.textContent?.toLowerCase()\n  }, [bag, id])\n\n  useIsoMorphicEffect(() => {\n    dispatch({ type: ActionTypes.RegisterItem, id, dataRef: bag })\n    return () => dispatch({ type: ActionTypes.UnregisterItem, id })\n  }, [bag, id])\n\n  let handleClick = useCallback(\n    (event: MouseEvent) => {\n      if (disabled) return event.preventDefault()\n      dispatch({ type: ActionTypes.CloseMenu })\n      disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n      if (onClick) return onClick(event)\n    },\n    [dispatch, state.buttonRef, disabled, onClick]\n  )\n\n  let handleFocus = useCallback(() => {\n    if (disabled) return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Nothing })\n    dispatch({ type: ActionTypes.GoToItem, focus: Focus.Specific, id })\n  }, [disabled, id, dispatch])\n\n  let handleMove = useCallback(() => {\n    if (disabled) return\n    if (active) return\n    dispatch({ type: ActionTypes.GoToItem, focus: Focus.Specific, id })\n  }, [disabled, active, id, dispatch])\n\n  let handleLeave = useCallback(() => {\n    if (disabled) return\n    if (!active) return\n    dispatch({ type: ActionTypes.GoToItem, focus: Focus.Nothing })\n  }, [disabled, active, dispatch])\n\n  let slot = useMemo<ItemRenderPropArg>(() => ({ active, disabled }), [active, disabled])\n  let propsWeControl = {\n    id,\n    role: 'menuitem',\n    tabIndex: disabled === true ? undefined : -1,\n    'aria-disabled': disabled === true ? true : undefined,\n    disabled: undefined, // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave,\n  }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_ITEM_TAG,\n    name: 'Menu.Item',\n  })\n}\n\n// ---\n\nMenu.Button = Button\nMenu.Items = Items\nMenu.Item = Item\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n  KeyboardEvent as ReactKeyboardEvent,\n  ContextType,\n} from 'react'\n\nimport { Props, Expand } from '../../types'\nimport { render } from '../../utils/render'\nimport { useId } from '../../hooks/use-id'\nimport { match } from '../../utils/match'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { Keys } from '../../components/keyboard'\nimport { focusIn, Focus, FocusResult } from '../../utils/focus-management'\nimport { useFlags } from '../../hooks/use-flags'\nimport { Label, useLabels } from '../../components/label/label'\nimport { Description, useDescriptions } from '../../components/description/description'\nimport { useTreeWalker } from '../../hooks/use-tree-walker'\n\ninterface Option {\n  id: string\n  element: MutableRefObject<HTMLElement | null>\n  propsRef: MutableRefObject<{ value: unknown; disabled: boolean }>\n}\n\ninterface StateDefinition {\n  options: Option[]\n}\n\nenum ActionTypes {\n  RegisterOption,\n  UnregisterOption,\n}\n\ntype Actions =\n  | Expand<{ type: ActionTypes.RegisterOption } & Option>\n  | { type: ActionTypes.UnregisterOption; id: Option['id'] }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.RegisterOption](state, action) {\n    return {\n      ...state,\n      options: [\n        ...state.options,\n        { id: action.id, element: action.element, propsRef: action.propsRef },\n      ],\n    }\n  },\n  [ActionTypes.UnregisterOption](state, action) {\n    let options = state.options.slice()\n    let idx = state.options.findIndex(radio => radio.id === action.id)\n    if (idx === -1) return state\n    options.splice(idx, 1)\n    return { ...state, options }\n  },\n}\n\nlet RadioGroupContext = createContext<{\n  registerOption(option: Option): () => void\n  change(value: unknown): boolean\n  value: unknown\n  firstOption?: Option\n  containsCheckedOption: boolean\n  disabled: boolean\n} | null>(null)\nRadioGroupContext.displayName = 'RadioGroupContext'\n\nfunction useRadioGroupContext(component: string) {\n  let context = useContext(RadioGroupContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${RadioGroup.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useRadioGroupContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_RADIO_GROUP_TAG = 'div' as const\ninterface RadioGroupRenderPropArg {}\ntype RadioGroupPropsWeControl = 'role' | 'aria-labelledby' | 'aria-describedby' | 'id'\n\nexport function RadioGroup<\n  TTag extends ElementType = typeof DEFAULT_RADIO_GROUP_TAG,\n  TType = string\n>(\n  props: Props<\n    TTag,\n    RadioGroupRenderPropArg,\n    RadioGroupPropsWeControl | 'value' | 'onChange' | 'disabled'\n  > & {\n    value: TType\n    onChange(value: TType): void\n    disabled?: boolean\n  }\n) {\n  let { value, onChange, disabled = false, ...passThroughProps } = props\n  let [{ options }, dispatch] = useReducer(stateReducer, {\n    options: [],\n  } as StateDefinition)\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n  let id = `headlessui-radiogroup-${useId()}`\n  let radioGroupRef = useRef<HTMLElement | null>(null)\n\n  let firstOption = useMemo(\n    () =>\n      options.find(option => {\n        if (option.propsRef.current.disabled) return false\n        return true\n      }),\n    [options]\n  )\n  let containsCheckedOption = useMemo(\n    () => options.some(option => option.propsRef.current.value === value),\n    [options, value]\n  )\n\n  let triggerChange = useCallback(\n    nextValue => {\n      if (disabled) return false\n      if (nextValue === value) return false\n      let nextOption = options.find(option => option.propsRef.current.value === nextValue)?.propsRef\n        .current\n      if (nextOption?.disabled) return false\n\n      onChange(nextValue)\n      return true\n    },\n    [onChange, value, disabled, options]\n  )\n\n  useTreeWalker({\n    container: radioGroupRef.current,\n    accept(node) {\n      if (node.getAttribute('role') === 'radio') return NodeFilter.FILTER_REJECT\n      if (node.hasAttribute('role')) return NodeFilter.FILTER_SKIP\n      return NodeFilter.FILTER_ACCEPT\n    },\n    walk(node) {\n      node.setAttribute('role', 'none')\n    },\n  })\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      let container = radioGroupRef.current\n      if (!container) return\n\n      let all = options\n        .filter(option => option.propsRef.current.disabled === false)\n        .map(radio => radio.element.current) as HTMLElement[]\n\n      switch (event.key) {\n        case Keys.ArrowLeft:\n        case Keys.ArrowUp:\n          {\n            event.preventDefault()\n            event.stopPropagation()\n\n            let result = focusIn(all, Focus.Previous | Focus.WrapAround)\n\n            if (result === FocusResult.Success) {\n              let activeOption = options.find(\n                option => option.element.current === document.activeElement\n              )\n              if (activeOption) triggerChange(activeOption.propsRef.current.value)\n            }\n          }\n          break\n\n        case Keys.ArrowRight:\n        case Keys.ArrowDown:\n          {\n            event.preventDefault()\n            event.stopPropagation()\n\n            let result = focusIn(all, Focus.Next | Focus.WrapAround)\n\n            if (result === FocusResult.Success) {\n              let activeOption = options.find(\n                option => option.element.current === document.activeElement\n              )\n              if (activeOption) triggerChange(activeOption.propsRef.current.value)\n            }\n          }\n          break\n\n        case Keys.Space:\n          {\n            event.preventDefault()\n            event.stopPropagation()\n\n            let activeOption = options.find(\n              option => option.element.current === document.activeElement\n            )\n            if (activeOption) triggerChange(activeOption.propsRef.current.value)\n          }\n          break\n      }\n    },\n    [radioGroupRef, options, triggerChange]\n  )\n\n  let registerOption = useCallback(\n    (option: Option) => {\n      dispatch({ type: ActionTypes.RegisterOption, ...option })\n      return () => dispatch({ type: ActionTypes.UnregisterOption, id: option.id })\n    },\n    [dispatch]\n  )\n\n  let api = useMemo<ContextType<typeof RadioGroupContext>>(\n    () => ({\n      registerOption,\n      firstOption,\n      containsCheckedOption,\n      change: triggerChange,\n      disabled,\n      value,\n    }),\n    [registerOption, firstOption, containsCheckedOption, triggerChange, disabled, value]\n  )\n\n  let propsWeControl = {\n    ref: radioGroupRef,\n    id,\n    role: 'radiogroup',\n    'aria-labelledby': labelledby,\n    'aria-describedby': describedby,\n    onKeyDown: handleKeyDown,\n  }\n\n  return (\n    <DescriptionProvider name=\"RadioGroup.Description\">\n      <LabelProvider name=\"RadioGroup.Label\">\n        <RadioGroupContext.Provider value={api}>\n          {render({\n            props: { ...passThroughProps, ...propsWeControl },\n            defaultTag: DEFAULT_RADIO_GROUP_TAG,\n            name: 'RadioGroup',\n          })}\n        </RadioGroupContext.Provider>\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nenum OptionState {\n  Empty = 1 << 0,\n  Active = 1 << 1,\n}\n\nlet DEFAULT_OPTION_TAG = 'div' as const\ninterface OptionRenderPropArg {\n  checked: boolean\n  active: boolean\n  disabled: boolean\n}\ntype RadioPropsWeControl =\n  | 'aria-checked'\n  | 'id'\n  | 'onBlur'\n  | 'onClick'\n  | 'onFocus'\n  | 'ref'\n  | 'role'\n  | 'tabIndex'\n\nfunction Option<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  // TODO: One day we will be able to infer this type from the generic in RadioGroup itself.\n  // But today is not that day..\n  TType = Parameters<typeof RadioGroup>[0]['value']\n>(\n  props: Props<TTag, OptionRenderPropArg, RadioPropsWeControl | 'value' | 'disabled'> & {\n    value: TType\n    disabled?: boolean\n  }\n) {\n  let optionRef = useRef<HTMLElement | null>(null)\n  let id = `headlessui-radiogroup-option-${useId()}`\n\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n  let { addFlag, removeFlag, hasFlag } = useFlags(OptionState.Empty)\n\n  let { value, disabled = false, ...passThroughProps } = props\n  let propsRef = useRef({ value, disabled })\n\n  useIsoMorphicEffect(() => {\n    propsRef.current.value = value\n  }, [value, propsRef])\n  useIsoMorphicEffect(() => {\n    propsRef.current.disabled = disabled\n  }, [disabled, propsRef])\n\n  let {\n    registerOption,\n    disabled: radioGroupDisabled,\n    change,\n    firstOption,\n    containsCheckedOption,\n    value: radioGroupValue,\n  } = useRadioGroupContext([RadioGroup.name, Option.name].join('.'))\n\n  useIsoMorphicEffect(() => registerOption({ id, element: optionRef, propsRef }), [\n    id,\n    registerOption,\n    optionRef,\n    props,\n  ])\n\n  let handleClick = useCallback(() => {\n    if (!change(value)) return\n\n    addFlag(OptionState.Active)\n    optionRef.current?.focus()\n  }, [addFlag, change, value])\n\n  let handleFocus = useCallback(() => addFlag(OptionState.Active), [addFlag])\n  let handleBlur = useCallback(() => removeFlag(OptionState.Active), [removeFlag])\n\n  let isFirstOption = firstOption?.id === id\n  let isDisabled = radioGroupDisabled || disabled\n\n  let checked = radioGroupValue === value\n  let propsWeControl = {\n    ref: optionRef,\n    id,\n    role: 'radio',\n    'aria-checked': checked ? 'true' : 'false',\n    'aria-labelledby': labelledby,\n    'aria-describedby': describedby,\n    'aria-disabled': isDisabled ? true : undefined,\n    tabIndex: (() => {\n      if (isDisabled) return -1\n      if (checked) return 0\n      if (!containsCheckedOption && isFirstOption) return 0\n      return -1\n    })(),\n    onClick: isDisabled ? undefined : handleClick,\n    onFocus: isDisabled ? undefined : handleFocus,\n    onBlur: isDisabled ? undefined : handleBlur,\n  }\n  let slot = useMemo<OptionRenderPropArg>(\n    () => ({ checked, disabled: isDisabled, active: hasFlag(OptionState.Active) }),\n    [checked, isDisabled, hasFlag]\n  )\n\n  return (\n    <DescriptionProvider name=\"RadioGroup.Description\">\n      <LabelProvider name=\"RadioGroup.Label\">\n        {render({\n          props: { ...passThroughProps, ...propsWeControl },\n          slot,\n          defaultTag: DEFAULT_OPTION_TAG,\n          name: 'RadioGroup.Option',\n        })}\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nRadioGroup.Option = Option\nRadioGroup.Label = Label\nRadioGroup.Description = Description\n","import { useState, useCallback } from 'react'\n\nexport function useFlags(initialFlags = 0) {\n  let [flags, setFlags] = useState(initialFlags)\n\n  let addFlag = useCallback((flag: number) => setFlags(flags => flags | flag), [setFlags])\n  let hasFlag = useCallback((flag: number) => Boolean(flags & flag), [flags])\n  let removeFlag = useCallback((flag: number) => setFlags(flags => flags & ~flag), [setFlags])\n  let toggleFlag = useCallback((flag: number) => setFlags(flags => flags ^ flag), [setFlags])\n\n  return { addFlag, hasFlag, removeFlag, toggleFlag }\n}\n"],"sourceRoot":""}