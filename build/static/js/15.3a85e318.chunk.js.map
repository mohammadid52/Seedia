{"version":3,"sources":["../../../src/utils/calculate-active-index.ts","../../../../src/components/listbox/listbox.tsx","../../../src/hooks/use-disposables.ts","../../../src/hooks/use-computed.ts","../../../../src/components/description/description.tsx","../../../../src/components/label/label.tsx","../../../../src/components/switch/switch.tsx"],"names":["Focus","useDisposables","d","useState","useEffect","useComputed","cb","dependencies","value","setValue","cbRef","useRef","useIsoMorphicEffect","calculateActiveIndex","action","resolvers","items","currentActiveIndex","activeIndex","nextActiveIndex","item","idx","all","x","Error","assertNever","ListboxStates","ActionTypes","reducers","state","activeOptionIndex","listboxState","Closed","Open","disabled","resolveItems","resolveActiveIndex","resolveId","resolveDisabled","searchQuery","match","option","options","id","dataRef","nextOptions","currentActiveOption","a","ListboxContext","createContext","useListboxContext","component","context","useContext","err","Listbox","stateReducer","DEFAULT_LISTBOX_TAG","props","onChange","passThroughProps","reducerBag","useReducer","propsRef","current","labelRef","createRef","buttonRef","optionsRef","dispatch","type","useWindowEvent","event","target","CloseListbox","isFocusableElement","FocusableMode","slot","useMemo","open","State","render","defaultTag","name","Button","forwardRefWithAs","useSyncRefs","useId","handleKeyDown","useCallback","Keys","OpenListbox","focus","First","Last","handleKeyUp","handleClick","isDisabledReactIssue7711","preventScroll","labelledby","passthroughProps","propsWeControl","ref","onKeyDown","onKeyUp","onClick","OptionsRenderFeatures","Features","Options","searchDisposables","usesOpenClosedState","useOpenClosed","visible","container","document","key","disposables","Next","Previous","ClearSearch","role","tabIndex","features","Label","Option","active","selected","bag","select","block","handleFocus","Nothing","handleMove","handleLeave","onFocus","onPointerMove","onMouseMove","onPointerLeave","onMouseLeave","DescriptionContext","useDescriptionContext","LabelContext","useLabelContext","GroupContext","DEFAULT_GROUP_TAG","Switch","checked","groupContext","toggle","handleKeyPress","onKeyPress","Object","switchElement","setSwitchElement","labelIds","setLabelIds","register","existing","clone","contextBag","useLabels","LabelProvider","descriptionIds","setDescriptionIds","useDescriptions","describedby","DescriptionProvider","switch","setSwitch","passive","allProps"],"mappings":"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","file":"static/js/15.3a85e318.chunk.js","sourcesContent":["function assertNever(x: never): never {\n  throw new Error('Unexpected object: ' + x)\n}\n\nexport enum Focus {\n  /** Focus the first non-disabled item. */\n  First,\n\n  /** Focus the previous non-disabled item. */\n  Previous,\n\n  /** Focus the next non-disabled item. */\n  Next,\n\n  /** Focus the last non-disabled item. */\n  Last,\n\n  /** Focus a specific item based on the `id` of the item. */\n  Specific,\n\n  /** Focus no items at all. */\n  Nothing,\n}\n\nexport function calculateActiveIndex<TItem>(\n  action: { focus: Focus.Specific; id: string } | { focus: Exclude<Focus, Focus.Specific> },\n  resolvers: {\n    resolveItems(): TItem[]\n    resolveActiveIndex(): number | null\n    resolveId(item: TItem): string\n    resolveDisabled(item: TItem): boolean\n  }\n) {\n  let items = resolvers.resolveItems()\n  if (items.length <= 0) return null\n\n  let currentActiveIndex = resolvers.resolveActiveIndex()\n  let activeIndex = currentActiveIndex ?? -1\n\n  let nextActiveIndex = (() => {\n    switch (action.focus) {\n      case Focus.First:\n        return items.findIndex(item => !resolvers.resolveDisabled(item))\n\n      case Focus.Previous: {\n        let idx = items\n          .slice()\n          .reverse()\n          .findIndex((item, idx, all) => {\n            if (activeIndex !== -1 && all.length - idx - 1 >= activeIndex) return false\n            return !resolvers.resolveDisabled(item)\n          })\n        if (idx === -1) return idx\n        return items.length - 1 - idx\n      }\n\n      case Focus.Next:\n        return items.findIndex((item, idx) => {\n          if (idx <= activeIndex) return false\n          return !resolvers.resolveDisabled(item)\n        })\n\n      case Focus.Last: {\n        let idx = items\n          .slice()\n          .reverse()\n          .findIndex(item => !resolvers.resolveDisabled(item))\n        if (idx === -1) return idx\n        return items.length - 1 - idx\n      }\n\n      case Focus.Specific:\n        return items.findIndex(item => resolvers.resolveId(item) === action.id)\n\n      case Focus.Nothing:\n        return null\n\n      default:\n        assertNever(action)\n    }\n  })()\n\n  return nextActiveIndex === -1 ? currentActiveIndex : nextActiveIndex\n}\n","import React, {\n  Fragment,\n  createContext,\n  createRef,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n\n  // Types\n  Dispatch,\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  MutableRefObject,\n  Ref,\n} from 'react'\n\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useComputed } from '../../hooks/use-computed'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { Props } from '../../types'\nimport { Features, forwardRefWithAs, PropsForFeatures, render } from '../../utils/render'\nimport { match } from '../../utils/match'\nimport { disposables } from '../../utils/disposables'\nimport { Keys } from '../keyboard'\nimport { Focus, calculateActiveIndex } from '../../utils/calculate-active-index'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { isFocusableElement, FocusableMode } from '../../utils/focus-management'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { useOpenClosed, State, OpenClosedProvider } from '../../internal/open-closed'\n\nenum ListboxStates {\n  Open,\n  Closed,\n}\n\ntype ListboxOptionDataRef = MutableRefObject<{\n  textValue?: string\n  disabled: boolean\n  value: unknown\n}>\n\ninterface StateDefinition {\n  listboxState: ListboxStates\n  propsRef: MutableRefObject<{ value: unknown; onChange(value: unknown): void }>\n  labelRef: MutableRefObject<HTMLLabelElement | null>\n  buttonRef: MutableRefObject<HTMLButtonElement | null>\n  optionsRef: MutableRefObject<HTMLUListElement | null>\n  disabled: boolean\n  options: { id: string; dataRef: ListboxOptionDataRef }[]\n  searchQuery: string\n  activeOptionIndex: number | null\n}\n\nenum ActionTypes {\n  OpenListbox,\n  CloseListbox,\n\n  SetDisabled,\n\n  GoToOption,\n  Search,\n  ClearSearch,\n\n  RegisterOption,\n  UnregisterOption,\n}\n\ntype Actions =\n  | { type: ActionTypes.CloseListbox }\n  | { type: ActionTypes.OpenListbox }\n  | { type: ActionTypes.SetDisabled; disabled: boolean }\n  | { type: ActionTypes.GoToOption; focus: Focus.Specific; id: string }\n  | { type: ActionTypes.GoToOption; focus: Exclude<Focus, Focus.Specific> }\n  | { type: ActionTypes.Search; value: string }\n  | { type: ActionTypes.ClearSearch }\n  | { type: ActionTypes.RegisterOption; id: string; dataRef: ListboxOptionDataRef }\n  | { type: ActionTypes.UnregisterOption; id: string }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.CloseListbox](state) {\n    if (state.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n    return { ...state, activeOptionIndex: null, listboxState: ListboxStates.Closed }\n  },\n  [ActionTypes.OpenListbox](state) {\n    if (state.disabled) return state\n    if (state.listboxState === ListboxStates.Open) return state\n    return { ...state, listboxState: ListboxStates.Open }\n  },\n  [ActionTypes.SetDisabled](state, action) {\n    if (state.disabled === action.disabled) return state\n    return { ...state, disabled: action.disabled }\n  },\n  [ActionTypes.GoToOption](state, action) {\n    if (state.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n\n    let activeOptionIndex = calculateActiveIndex(action, {\n      resolveItems: () => state.options,\n      resolveActiveIndex: () => state.activeOptionIndex,\n      resolveId: item => item.id,\n      resolveDisabled: item => item.dataRef.current.disabled,\n    })\n\n    if (state.searchQuery === '' && state.activeOptionIndex === activeOptionIndex) return state\n    return { ...state, searchQuery: '', activeOptionIndex }\n  },\n  [ActionTypes.Search]: (state, action) => {\n    if (state.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n\n    let searchQuery = state.searchQuery + action.value.toLowerCase()\n    let match = state.options.findIndex(\n      option =>\n        !option.dataRef.current.disabled &&\n        option.dataRef.current.textValue?.startsWith(searchQuery)\n    )\n\n    if (match === -1 || match === state.activeOptionIndex) return { ...state, searchQuery }\n    return { ...state, searchQuery, activeOptionIndex: match }\n  },\n  [ActionTypes.ClearSearch](state) {\n    if (state.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n    if (state.searchQuery === '') return state\n    return { ...state, searchQuery: '' }\n  },\n  [ActionTypes.RegisterOption]: (state, action) => ({\n    ...state,\n    options: [...state.options, { id: action.id, dataRef: action.dataRef }],\n  }),\n  [ActionTypes.UnregisterOption]: (state, action) => {\n    let nextOptions = state.options.slice()\n    let currentActiveOption =\n      state.activeOptionIndex !== null ? nextOptions[state.activeOptionIndex] : null\n\n    let idx = nextOptions.findIndex(a => a.id === action.id)\n\n    if (idx !== -1) nextOptions.splice(idx, 1)\n\n    return {\n      ...state,\n      options: nextOptions,\n      activeOptionIndex: (() => {\n        if (idx === state.activeOptionIndex) return null\n        if (currentActiveOption === null) return null\n\n        // If we removed the option before the actual active index, then it would be out of sync. To\n        // fix this, we will find the correct (new) index position.\n        return nextOptions.indexOf(currentActiveOption)\n      })(),\n    }\n  },\n}\n\nlet ListboxContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nListboxContext.displayName = 'ListboxContext'\n\nfunction useListboxContext(component: string) {\n  let context = useContext(ListboxContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Listbox.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useListboxContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_LISTBOX_TAG = Fragment\ninterface ListboxRenderPropArg {\n  open: boolean\n  disabled: boolean\n}\n\nexport function Listbox<TTag extends ElementType = typeof DEFAULT_LISTBOX_TAG, TType = string>(\n  props: Props<TTag, ListboxRenderPropArg, 'value' | 'onChange'> & {\n    value: TType\n    onChange(value: TType): void\n    disabled?: boolean\n  }\n) {\n  let { value, onChange, disabled = false, ...passThroughProps } = props\n  let reducerBag = useReducer(stateReducer, {\n    listboxState: ListboxStates.Closed,\n    propsRef: { current: { value, onChange } },\n    labelRef: createRef(),\n    buttonRef: createRef(),\n    optionsRef: createRef(),\n    disabled,\n    options: [],\n    searchQuery: '',\n    activeOptionIndex: null,\n  } as StateDefinition)\n  let [{ listboxState, propsRef, optionsRef, buttonRef }, dispatch] = reducerBag\n\n  useIsoMorphicEffect(() => {\n    propsRef.current.value = value\n  }, [value, propsRef])\n  useIsoMorphicEffect(() => {\n    propsRef.current.onChange = onChange\n  }, [onChange, propsRef])\n  useIsoMorphicEffect(() => dispatch({ type: ActionTypes.SetDisabled, disabled }), [disabled])\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (listboxState !== ListboxStates.Open) return\n\n    if (buttonRef.current?.contains(target)) return\n    if (optionsRef.current?.contains(target)) return\n\n    dispatch({ type: ActionTypes.CloseListbox })\n\n    if (!isFocusableElement(target, FocusableMode.Loose)) {\n      event.preventDefault()\n      buttonRef.current?.focus()\n    }\n  })\n\n  let slot = useMemo<ListboxRenderPropArg>(\n    () => ({ open: listboxState === ListboxStates.Open, disabled }),\n    [listboxState, disabled]\n  )\n\n  return (\n    <ListboxContext.Provider value={reducerBag}>\n      <OpenClosedProvider\n        value={match(listboxState, {\n          [ListboxStates.Open]: State.Open,\n          [ListboxStates.Closed]: State.Closed,\n        })}\n      >\n        {render({\n          props: passThroughProps,\n          slot,\n          defaultTag: DEFAULT_LISTBOX_TAG,\n          name: 'Listbox',\n        })}\n      </OpenClosedProvider>\n    </ListboxContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ninterface ButtonRenderPropArg {\n  open: boolean\n  disabled: boolean\n}\ntype ButtonPropsWeControl =\n  | 'id'\n  | 'type'\n  | 'aria-haspopup'\n  | 'aria-controls'\n  | 'aria-expanded'\n  | 'aria-labelledby'\n  | 'disabled'\n  | 'onKeyDown'\n  | 'onClick'\n\nlet Button = forwardRefWithAs(function Button<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: Props<TTag, ButtonRenderPropArg, ButtonPropsWeControl>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let [state, dispatch] = useListboxContext([Listbox.name, Button.name].join('.'))\n  let buttonRef = useSyncRefs(state.buttonRef, ref)\n\n  let id = `headlessui-listbox-button-${useId()}`\n  let d = useDisposables()\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      switch (event.key) {\n        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-13\n\n        case Keys.Space:\n        case Keys.Enter:\n        case Keys.ArrowDown:\n          event.preventDefault()\n          dispatch({ type: ActionTypes.OpenListbox })\n          d.nextFrame(() => {\n            if (!state.propsRef.current.value)\n              dispatch({ type: ActionTypes.GoToOption, focus: Focus.First })\n          })\n          break\n\n        case Keys.ArrowUp:\n          event.preventDefault()\n          dispatch({ type: ActionTypes.OpenListbox })\n          d.nextFrame(() => {\n            if (!state.propsRef.current.value)\n              dispatch({ type: ActionTypes.GoToOption, focus: Focus.Last })\n          })\n          break\n      }\n    },\n    [dispatch, state, d]\n  )\n\n  let handleKeyUp = useCallback((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  }, [])\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      if (state.listboxState === ListboxStates.Open) {\n        dispatch({ type: ActionTypes.CloseListbox })\n        d.nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n      } else {\n        event.preventDefault()\n        dispatch({ type: ActionTypes.OpenListbox })\n      }\n    },\n    [dispatch, d, state]\n  )\n\n  let labelledby = useComputed(() => {\n    if (!state.labelRef.current) return undefined\n    return [state.labelRef.current.id, id].join(' ')\n  }, [state.labelRef.current, id])\n\n  let slot = useMemo<ButtonRenderPropArg>(\n    () => ({ open: state.listboxState === ListboxStates.Open, disabled: state.disabled }),\n    [state]\n  )\n  let passthroughProps = props\n  let propsWeControl = {\n    ref: buttonRef,\n    id,\n    type: 'button',\n    'aria-haspopup': true,\n    'aria-controls': state.optionsRef.current?.id,\n    'aria-expanded': state.disabled ? undefined : state.listboxState === ListboxStates.Open,\n    'aria-labelledby': labelledby,\n    disabled: state.disabled,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onClick: handleClick,\n  }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Listbox.Button',\n  })\n})\n\n// ---\n\nlet DEFAULT_LABEL_TAG = 'label' as const\ninterface LabelRenderPropArg {\n  open: boolean\n  disabled: boolean\n}\ntype LabelPropsWeControl = 'id' | 'ref' | 'onClick'\n\nfunction Label<TTag extends ElementType = typeof DEFAULT_LABEL_TAG>(\n  props: Props<TTag, LabelRenderPropArg, LabelPropsWeControl>\n) {\n  let [state] = useListboxContext([Listbox.name, Label.name].join('.'))\n  let id = `headlessui-listbox-label-${useId()}`\n\n  let handleClick = useCallback(() => state.buttonRef.current?.focus({ preventScroll: true }), [\n    state.buttonRef,\n  ])\n\n  let slot = useMemo<LabelRenderPropArg>(\n    () => ({ open: state.listboxState === ListboxStates.Open, disabled: state.disabled }),\n    [state]\n  )\n  let propsWeControl = { ref: state.labelRef, id, onClick: handleClick }\n  return render({\n    props: { ...props, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_LABEL_TAG,\n    name: 'Listbox.Label',\n  })\n}\n\n// ---\n\nlet DEFAULT_OPTIONS_TAG = 'ul' as const\ninterface OptionsRenderPropArg {\n  open: boolean\n}\ntype OptionsPropsWeControl =\n  | 'aria-activedescendant'\n  | 'aria-labelledby'\n  | 'id'\n  | 'onKeyDown'\n  | 'role'\n  | 'tabIndex'\n\nlet OptionsRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Options = forwardRefWithAs(function Options<\n  TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG\n>(\n  props: Props<TTag, OptionsRenderPropArg, OptionsPropsWeControl> &\n    PropsForFeatures<typeof OptionsRenderFeatures>,\n  ref: Ref<HTMLUListElement>\n) {\n  let [state, dispatch] = useListboxContext([Listbox.name, Options.name].join('.'))\n  let optionsRef = useSyncRefs(state.optionsRef, ref)\n\n  let id = `headlessui-listbox-options-${useId()}`\n  let d = useDisposables()\n  let searchDisposables = useDisposables()\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return state.listboxState === ListboxStates.Open\n  })()\n\n  useIsoMorphicEffect(() => {\n    let container = state.optionsRef.current\n    if (!container) return\n    if (state.listboxState !== ListboxStates.Open) return\n    if (container === document.activeElement) return\n\n    container.focus({ preventScroll: true })\n  }, [state.listboxState, state.optionsRef])\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLUListElement>) => {\n      searchDisposables.dispose()\n\n      switch (event.key) {\n        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-12\n\n        // @ts-expect-error Fallthrough is expected here\n        case Keys.Space:\n          if (state.searchQuery !== '') {\n            event.preventDefault()\n            event.stopPropagation()\n            return dispatch({ type: ActionTypes.Search, value: event.key })\n          }\n        // When in type ahead mode, fallthrough\n        case Keys.Enter:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.CloseListbox })\n          if (state.activeOptionIndex !== null) {\n            let { dataRef } = state.options[state.activeOptionIndex]\n            state.propsRef.current.onChange(dataRef.current.value)\n          }\n          disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n          break\n\n        case Keys.ArrowDown:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Next })\n\n        case Keys.ArrowUp:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Previous })\n\n        case Keys.Home:\n        case Keys.PageUp:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToOption, focus: Focus.First })\n\n        case Keys.End:\n        case Keys.PageDown:\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Last })\n\n        case Keys.Escape:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.CloseListbox })\n          return d.nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n\n        case Keys.Tab:\n          event.preventDefault()\n          event.stopPropagation()\n          break\n\n        default:\n          if (event.key.length === 1) {\n            dispatch({ type: ActionTypes.Search, value: event.key })\n            searchDisposables.setTimeout(() => dispatch({ type: ActionTypes.ClearSearch }), 350)\n          }\n          break\n      }\n    },\n    [d, dispatch, searchDisposables, state]\n  )\n\n  let labelledby = useComputed(() => state.labelRef.current?.id ?? state.buttonRef.current?.id, [\n    state.labelRef.current,\n    state.buttonRef.current,\n  ])\n\n  let slot = useMemo<OptionsRenderPropArg>(\n    () => ({ open: state.listboxState === ListboxStates.Open }),\n    [state]\n  )\n  let propsWeControl = {\n    'aria-activedescendant':\n      state.activeOptionIndex === null ? undefined : state.options[state.activeOptionIndex]?.id,\n    'aria-labelledby': labelledby,\n    id,\n    onKeyDown: handleKeyDown,\n    role: 'listbox',\n    tabIndex: 0,\n    ref: optionsRef,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG,\n    features: OptionsRenderFeatures,\n    visible,\n    name: 'Listbox.Options',\n  })\n})\n\n// ---\n\nlet DEFAULT_OPTION_TAG = 'li' as const\ninterface OptionRenderPropArg {\n  active: boolean\n  selected: boolean\n  disabled: boolean\n}\ntype ListboxOptionPropsWeControl =\n  | 'id'\n  | 'role'\n  | 'tabIndex'\n  | 'aria-disabled'\n  | 'aria-selected'\n  | 'onPointerLeave'\n  | 'onMouseLeave'\n  | 'onPointerMove'\n  | 'onMouseMove'\n  | 'onFocus'\n\nfunction Option<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  // TODO: One day we will be able to infer this type from the generic in Listbox itself.\n  // But today is not that day..\n  TType = Parameters<typeof Listbox>[0]['value']\n>(\n  props: Props<TTag, OptionRenderPropArg, ListboxOptionPropsWeControl | 'value'> & {\n    disabled?: boolean\n    value: TType\n  }\n) {\n  let { disabled = false, value, ...passthroughProps } = props\n  let [state, dispatch] = useListboxContext([Listbox.name, Option.name].join('.'))\n  let id = `headlessui-listbox-option-${useId()}`\n  let active =\n    state.activeOptionIndex !== null ? state.options[state.activeOptionIndex].id === id : false\n  let selected = state.propsRef.current.value === value\n\n  let bag = useRef<ListboxOptionDataRef['current']>({ disabled, value })\n\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled\n  }, [bag, disabled])\n  useIsoMorphicEffect(() => {\n    bag.current.value = value\n  }, [bag, value])\n  useIsoMorphicEffect(() => {\n    bag.current.textValue = document.getElementById(id)?.textContent?.toLowerCase()\n  }, [bag, id])\n\n  let select = useCallback(() => state.propsRef.current.onChange(value), [state.propsRef, value])\n\n  useIsoMorphicEffect(() => {\n    dispatch({ type: ActionTypes.RegisterOption, id, dataRef: bag })\n    return () => dispatch({ type: ActionTypes.UnregisterOption, id })\n  }, [bag, id])\n\n  useIsoMorphicEffect(() => {\n    if (state.listboxState !== ListboxStates.Open) return\n    if (!selected) return\n    dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, id })\n    document.getElementById(id)?.focus?.()\n  }, [state.listboxState])\n\n  useIsoMorphicEffect(() => {\n    if (state.listboxState !== ListboxStates.Open) return\n    if (!active) return\n    let d = disposables()\n    d.nextFrame(() => document.getElementById(id)?.scrollIntoView?.({ block: 'nearest' }))\n    return d.dispose\n  }, [id, active, state.listboxState])\n\n  let handleClick = useCallback(\n    (event: { preventDefault: Function }) => {\n      if (disabled) return event.preventDefault()\n      select()\n      dispatch({ type: ActionTypes.CloseListbox })\n      disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n    },\n    [dispatch, state.buttonRef, disabled, select]\n  )\n\n  let handleFocus = useCallback(() => {\n    if (disabled) return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Nothing })\n    dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, id })\n  }, [disabled, id, dispatch])\n\n  let handleMove = useCallback(() => {\n    if (disabled) return\n    if (active) return\n    dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, id })\n  }, [disabled, active, id, dispatch])\n\n  let handleLeave = useCallback(() => {\n    if (disabled) return\n    if (!active) return\n    dispatch({ type: ActionTypes.GoToOption, focus: Focus.Nothing })\n  }, [disabled, active, dispatch])\n\n  let slot = useMemo<OptionRenderPropArg>(() => ({ active, selected, disabled }), [\n    active,\n    selected,\n    disabled,\n  ])\n  let propsWeControl = {\n    id,\n    role: 'option',\n    tabIndex: disabled === true ? undefined : -1,\n    'aria-disabled': disabled === true ? true : undefined,\n    'aria-selected': selected === true ? true : undefined,\n    disabled: undefined, // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave,\n  }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG,\n    name: 'Listbox.Option',\n  })\n}\n\n// ---\n\nListbox.Button = Button\nListbox.Label = Label\nListbox.Options = Options\nListbox.Option = Option\n","import { useState, useEffect } from 'react'\n\nimport { disposables } from '../utils/disposables'\n\nexport function useDisposables() {\n  // Using useState instead of useRef so that we can use the initializer function.\n  let [d] = useState(disposables)\n  useEffect(() => () => d.dispose(), [d])\n  return d\n}\n","import { useState, useRef } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nexport function useComputed<T>(cb: () => T, dependencies: React.DependencyList) {\n  let [value, setValue] = useState(cb)\n  let cbRef = useRef(cb)\n  useIsoMorphicEffect(() => {\n    cbRef.current = cb\n  }, [cb])\n  useIsoMorphicEffect(() => setValue(cbRef.current), [cbRef, setValue, ...dependencies])\n  return value\n}\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n\n  // Types\n  ElementType,\n  ReactNode,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { useId } from '../../hooks/use-id'\nimport { render } from '../../utils/render'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\n// ---\n\ninterface SharedData {\n  slot?: {}\n  name?: string\n  props?: {}\n}\n\nlet DescriptionContext = createContext<\n  ({ register(value: string): () => void } & SharedData) | null\n>(null)\n\nfunction useDescriptionContext() {\n  let context = useContext(DescriptionContext)\n  if (context === null) {\n    let err = new Error(\n      'You used a <Description /> component, but it is not inside a relevant parent.'\n    )\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDescriptionContext)\n    throw err\n  }\n  return context\n}\n\ninterface DescriptionProviderProps extends SharedData {\n  children: ReactNode\n}\n\nexport function useDescriptions(): [\n  string | undefined,\n  (props: DescriptionProviderProps) => JSX.Element\n] {\n  let [descriptionIds, setDescriptionIds] = useState<string[]>([])\n\n  return [\n    // The actual id's as string or undefined\n    descriptionIds.length > 0 ? descriptionIds.join(' ') : undefined,\n\n    // The provider component\n    useMemo(() => {\n      return function DescriptionProvider(props: DescriptionProviderProps) {\n        let register = useCallback((value: string) => {\n          setDescriptionIds(existing => [...existing, value])\n\n          return () =>\n            setDescriptionIds(existing => {\n              let clone = existing.slice()\n              let idx = clone.indexOf(value)\n              if (idx !== -1) clone.splice(idx, 1)\n              return clone\n            })\n        }, [])\n\n        let contextBag = useMemo(\n          () => ({ register, slot: props.slot, name: props.name, props: props.props }),\n          [register, props.slot, props.name, props.props]\n        )\n\n        return (\n          <DescriptionContext.Provider value={contextBag}>\n            {props.children}\n          </DescriptionContext.Provider>\n        )\n      }\n    }, [setDescriptionIds]),\n  ]\n}\n\n// ---\n\nlet DEFAULT_DESCRIPTION_TAG = 'p' as const\ninterface DescriptionRenderPropArg {}\ntype DescriptionPropsWeControl = 'id'\n\nexport function Description<TTag extends ElementType = typeof DEFAULT_DESCRIPTION_TAG>(\n  props: Props<TTag, DescriptionRenderPropArg, DescriptionPropsWeControl>\n) {\n  let context = useDescriptionContext()\n  let id = `headlessui-description-${useId()}`\n\n  useIsoMorphicEffect(() => context.register(id), [id, context.register])\n\n  let passThroughProps = props\n  let propsWeControl = { ...context.props, id }\n\n  return render({\n    props: { ...passThroughProps, ...propsWeControl },\n    slot: context.slot || {},\n    defaultTag: DEFAULT_DESCRIPTION_TAG,\n    name: context.name || 'Description',\n  })\n}\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n\n  // Types\n  ElementType,\n  ReactNode,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { useId } from '../../hooks/use-id'\nimport { render } from '../../utils/render'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\n// ---\n\ninterface SharedData {\n  slot?: {}\n  name?: string\n  props?: {}\n}\n\nlet LabelContext = createContext<({ register(value: string): () => void } & SharedData) | null>(\n  null\n)\n\nfunction useLabelContext() {\n  let context = useContext(LabelContext)\n  if (context === null) {\n    let err = new Error('You used a <Label /> component, but it is not inside a relevant parent.')\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useLabelContext)\n    throw err\n  }\n  return context\n}\n\ninterface LabelProviderProps extends SharedData {\n  children: ReactNode\n}\n\nexport function useLabels(): [string | undefined, (props: LabelProviderProps) => JSX.Element] {\n  let [labelIds, setLabelIds] = useState<string[]>([])\n\n  return [\n    // The actual id's as string or undefined.\n    labelIds.length > 0 ? labelIds.join(' ') : undefined,\n\n    // The provider component\n    useMemo(() => {\n      return function LabelProvider(props: LabelProviderProps) {\n        let register = useCallback((value: string) => {\n          setLabelIds(existing => [...existing, value])\n\n          return () =>\n            setLabelIds(existing => {\n              let clone = existing.slice()\n              let idx = clone.indexOf(value)\n              if (idx !== -1) clone.splice(idx, 1)\n              return clone\n            })\n        }, [])\n\n        let contextBag = useMemo(\n          () => ({ register, slot: props.slot, name: props.name, props: props.props }),\n          [register, props.slot, props.name, props.props]\n        )\n\n        return <LabelContext.Provider value={contextBag}>{props.children}</LabelContext.Provider>\n      }\n    }, [setLabelIds]),\n  ]\n}\n\n// ---\n\nlet DEFAULT_LABEL_TAG = 'label' as const\ninterface LabelRenderPropArg {}\ntype LabelPropsWeControl = 'id'\n\nexport function Label<TTag extends ElementType = typeof DEFAULT_LABEL_TAG>(\n  props: Props<TTag, LabelRenderPropArg, LabelPropsWeControl> & {\n    passive?: boolean\n  }\n) {\n  let { passive = false, ...passThroughProps } = props\n  let context = useLabelContext()\n  let id = `headlessui-label-${useId()}`\n\n  useIsoMorphicEffect(() => context.register(id), [id, context.register])\n\n  let propsWeControl = { ...context.props, id }\n\n  let allProps = { ...passThroughProps, ...propsWeControl }\n  // @ts-expect-error props are dynamic via context, some components will\n  //                  provide an onClick then we can delete it.\n  if (passive) delete allProps['onClick']\n\n  return render({\n    props: allProps,\n    slot: context.slot || {},\n    defaultTag: DEFAULT_LABEL_TAG,\n    name: context.name || 'Label',\n  })\n}\n","import React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n\n  // Types\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { render } from '../../utils/render'\nimport { useId } from '../../hooks/use-id'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { Label, useLabels } from '../label/label'\nimport { Description, useDescriptions } from '../description/description'\n\ninterface StateDefinition {\n  switch: HTMLButtonElement | null\n  setSwitch(element: HTMLButtonElement): void\n  labelledby: string | undefined\n  describedby: string | undefined\n}\n\nlet GroupContext = createContext<StateDefinition | null>(null)\nGroupContext.displayName = 'GroupContext'\n\n// ---\n\nlet DEFAULT_GROUP_TAG = Fragment\n\nfunction Group<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(props: Props<TTag>) {\n  let [switchElement, setSwitchElement] = useState<HTMLButtonElement | null>(null)\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let context = useMemo<StateDefinition>(\n    () => ({ switch: switchElement, setSwitch: setSwitchElement, labelledby, describedby }),\n    [switchElement, setSwitchElement, labelledby, describedby]\n  )\n\n  return (\n    <DescriptionProvider name=\"Switch.Description\">\n      <LabelProvider\n        name=\"Switch.Label\"\n        props={{\n          onClick() {\n            if (!switchElement) return\n            switchElement.click()\n            switchElement.focus({ preventScroll: true })\n          },\n        }}\n      >\n        <GroupContext.Provider value={context}>\n          {render({ props, defaultTag: DEFAULT_GROUP_TAG, name: 'Switch.Group' })}\n        </GroupContext.Provider>\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_SWITCH_TAG = 'button' as const\ninterface SwitchRenderPropArg {\n  checked: boolean\n}\ntype SwitchPropsWeControl =\n  | 'id'\n  | 'role'\n  | 'tabIndex'\n  | 'aria-checked'\n  | 'aria-labelledby'\n  | 'aria-describedby'\n  | 'onClick'\n  | 'onKeyUp'\n  | 'onKeyPress'\n\nexport function Switch<TTag extends ElementType = typeof DEFAULT_SWITCH_TAG>(\n  props: Props<TTag, SwitchRenderPropArg, SwitchPropsWeControl | 'checked' | 'onChange'> & {\n    checked: boolean\n    onChange(checked: boolean): void\n  }\n) {\n  let { checked, onChange, ...passThroughProps } = props\n  let id = `headlessui-switch-${useId()}`\n  let groupContext = useContext(GroupContext)\n\n  let toggle = useCallback(() => onChange(!checked), [onChange, checked])\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      event.preventDefault()\n      toggle()\n    },\n    [toggle]\n  )\n  let handleKeyUp = useCallback(\n    (event: ReactKeyboardEvent<HTMLElement>) => {\n      if (event.key !== Keys.Tab) event.preventDefault()\n      if (event.key === Keys.Space) toggle()\n    },\n    [toggle]\n  )\n\n  // This is needed so that we can \"cancel\" the click event when we use the `Enter` key on a button.\n  let handleKeyPress = useCallback(\n    (event: ReactKeyboardEvent<HTMLElement>) => event.preventDefault(),\n    []\n  )\n\n  let slot = useMemo<SwitchRenderPropArg>(() => ({ checked }), [checked])\n  let propsWeControl = {\n    id,\n    ref: groupContext === null ? undefined : groupContext.setSwitch,\n    role: 'switch',\n    tabIndex: 0,\n    'aria-checked': checked,\n    'aria-labelledby': groupContext?.labelledby,\n    'aria-describedby': groupContext?.describedby,\n    onClick: handleClick,\n    onKeyUp: handleKeyUp,\n    onKeyPress: handleKeyPress,\n  }\n\n  if (passThroughProps.as === 'button') {\n    Object.assign(propsWeControl, { type: 'button' })\n  }\n\n  return render({\n    props: { ...passThroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_SWITCH_TAG,\n    name: 'Switch',\n  })\n}\n\n// ---\n\nSwitch.Group = Group\nSwitch.Label = Label\nSwitch.Description = Description\n"],"sourceRoot":""}